<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手动安装SSH服务</title>
      <link href="/posts/ubuntu@01.html"/>
      <url>/posts/ubuntu@01.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">安装SSH时，国外源无法访问，更换国内源仍然无果，可能地区特殊，网络做了类似于运营商的缓存劫持限制。</div><h1 id="1-Zlib"><a href="#1-Zlib" class="headerlink" title="1 Zlib"></a>1 Zlib</h1><ul><li>提供了数据压缩用的函式库(源码包)，由Jean-loup Gailly与Mark Adler开发。</li><li>使用DEFLATE算法，最初是为了Libpng函式库所写，官网：<a href="https://zlib.net/">https://zlib.net/</a>。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo tar zxvf zlib-xxx.tar.gz             # 解压zlib-xxx.tar.gz$ cd zlib-xxx&#x2F;                              # 进入解压的zlib-xxx目录中$ .&#x2F;configure                               # 执行配置脚本文件$ make                                      # 编译环境$ sudo make install                         # 安装zlib$ sudo .&#x2F;configure &amp;&amp; make &amp;&amp; make install  # 命令可以连起来用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-OpenSSL"><a href="#2-OpenSSL" class="headerlink" title="2 OpenSSL"></a>2 OpenSSL</h1><ul><li>一个安全套接字层密码库，囊括主要的密码算法、常用密钥、证书封装管理功能及实现SSL协议。</li><li>主要分成了SSL协议库、应用程序、密码算法库三个功能部分，官网：<a href="http://www.openssl.org/">http://www.openssl.org/</a>。</li><li><code>--prefix</code>：配置安装目录。<ul><li>不配置安装后，可执行文件默认放在/usr/local/bin，库文件放在/usr/local/lib。</li><li>配置文件默认放在/usr/local/etc，其他资源文件放在/usr/local/share，比较乱。</li><li>配置安装后，所有的资源文件都会被放在指定目录中，不会被分散到其他地方。</li></ul></li><li><code>--openssldir</code>：配置文件目录。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo tar zxvf openssl-xxx.tar.gz          # 解压openssl-xxx.tar.gz$ cd openssl-xxx&#x2F;                           # 进入解压的openssl-xxx目录中$ .&#x2F;config --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl --openssldir&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl$ make                                      # 编译环境$ sudo make install                         # 安装openssl$ openssl version                           # 验证openssl是否安装成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-OpenSSH"><a href="#3-OpenSSH" class="headerlink" title="3 OpenSSH"></a>3 OpenSSH</h1><ul><li>SSH，Secure Shell协议的免费开源实现，对传输的数据进行加密从而提高数据的安全性。</li><li>提供了服务端后台程序和客户端工具，用来加密数据，官网：<a href="http://www.openssh.com/">http://www.openssh.com/</a>。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo tar zxvf openssh-xxx.tar.gz          # 解压openssh-xxx.tar.gz$ cd openssh-xxx&#x2F;                           # 进入解压的openssh-xxx目录中$ .&#x2F;configure                               # 执行配置脚本文件$ make                                      # 编译环境$ sudo gedit &#x2F;etc&#x2F;passwd                    # 添加内容，该文件用于用户登录时校验口令# 不添加SSH可能启动不了，报错提示：Privilege separation user sshd does not exist# 添加内容：sshd:x:74:74:Provilege-separated SSH:&#x2F;var&#x2F;empty&#x2F;sshd:&#x2F;sbin&#x2F;nologin# 添加信息：注册名:口令Pwd:用户标识号UID:组标识号GID:用户名:用户主目录:命令解释程序$ sudo make install                         # 安装openssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4 启动服务"></a>4 启动服务</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;sshd                 # 启动ssh-server$ netstat –tnlp | grep :22                  # 查看并监听22端口，ssh服务默认开启端口$ ssh localhost                             # 尝试从本机登录，成功登录说明安装成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="5-配置开机启动"><a href="#5-配置开机启动" class="headerlink" title="5 配置开机启动"></a>5 配置开机启动</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo gedit &#x2F;etc&#x2F;rc.local                  # 需另起一个Terminal，否则报错# sudo &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;sshd                 # 将该命令写入rc.local文件当中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter介绍</title>
      <link href="/posts/flutter@01.html"/>
      <url>/posts/flutter@01.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Flutter横跨Android、iOS、MacOS、Windows、Linux等多个系统，使用Dart语言，并通过热重载功能实现快速开发和迭代。</div><h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h1><ul><li>虚拟机下Win10企业版(<a href="ed2k://|file|cn_windows_10_business_editions_version_1909_x64_dvd_0ca83907.iso|5275090944|9BCD5FA6C8009E4D0260E4B23008BD47|/">Win10-1909-Business-Editions-DVD-x64</a>)、Chrome。</li><li>下载安装Flutter依赖的命令行工具Git For Windows：<a href="https://github.com/git-for-windows/git/releases/download/v2.37.1.windows.1/Git-2.37.1-64-bit.exe">Git-2.37.1-64-bit.exe</a>。</li><li>Flutter SDK下载：<a href="https://storage.googleapis.com/flutter_infra_release/releases/stable/windows/flutter_windows_3.0.5-stable.zip">Flutter-Windows-3.0.5-Stable.zip</a>。<ul><li>解压到指定位置，找到文件夹中的flutter_console.bat文件，双击运行。</li><li>注意：不要将Flutter SDK安装到高权限路径下，例如C盘路径(系统盘)。</li></ul></li><li>添加环境变量：控制面板—&gt;用户账户—&gt;更改我的环境变量—&gt;环境变量。<ul><li>新建变量名<code>PUB_HOSTED_URL</code>：变量值<code>https://pub.flutter-io.cn/</code>。</li><li>新建变量名<code>FLUTTER_STORAGE_BASE_URL</code>：变量值<code>https://storage.flutter-io.cn/</code>。</li><li>在变量Path中添加：变量值<code>C:\Program\Flutter\bin</code>(Flutter SDK安装路径的bin目录)。</li></ul></li></ul><h1 id="2-编辑器的安装"><a href="#2-编辑器的安装" class="headerlink" title="2 编辑器的安装"></a>2 编辑器的安装</h1><ul><li>安装Visual Studio：<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Professional&amp;channel=Release&amp;version=VS2022&amp;source=VSLandingPage&amp;cid=2030&amp;passive=false">VisualStudioSetup.exe</a>，使用C++的桌面工具。<ul><li>勾选<code>用于Windows的C++ CMake工具</code>。</li><li>勾选<code>Windows 10 SDK(10.0.19041.0)</code>。</li><li>勾选<code>MSVC v143-VS 2022 C++ x64/86生成工具(最新)</code>。</li></ul></li><li>安装Android Studio：<a href="https://redirector.gvt1.com/edgedl/android/studio/install/2021.2.1.15/android-studio-2021.2.1.15-windows.exe">Android-Studio-2021.2.1.15-Windows.exe</a>，可能需要使用梯子。<ul><li>添加环境变量<code>ANDROID_SDK_HOME</code>：变量值<code>C:\Program\Avd</code> (即模拟器存放的位置)。</li><li>设置Android模拟器：虚拟机貌似无法启动模拟器，建议将环境搭建在Pc主机上操作。<ul><li>Android Studio—&gt;More Actions—&gt;Virtual Device Manager—&gt;Create device。</li><li>Phone·Pixel—&gt;Next—&gt;镜像 R—&gt;Download—&gt;Next—&gt;验证配置—&gt;Finish。</li></ul></li><li>安装插件：Android Studio—&gt;Plugins—&gt;Marketplace—&gt;搜Flutter和Dart—&gt;Install。<ul><li>Flutter插件：支持Flutter开发工作流(运行、调试、热重载等)。</li><li>Dart插件：提供代码分析(输入代码时进行验证、代码补全等)。</li></ul></li></ul></li></ul><h1 id="3-flutter-doctor"><a href="#3-flutter-doctor" class="headerlink" title="3 flutter doctor"></a>3 flutter doctor</h1><ul><li>文件夹下鼠标右键<code>Git Bash Here</code>，命令窗口模式输入<code>flutter doctor</code>进行查看。</li><li><code>cmdline-tools component is missing</code>：Android Studio缺少cmdline-tools工具。<ul><li>启动Android Studio—&gt;More Actions—&gt;SDK Manager—&gt;SDK Tools。</li><li>Android SDK Command-line Tools (latest)—&gt;Apply—&gt;Finish—&gt;OK。</li></ul></li><li><code>Android license status unknown.</code>：说明该环境需要添加Android license。<ul><li>搜索<code>cmd</code>，以管理员身份运行，命令窗口下执行<code>flutter doctor --android-licenses</code>。</li><li>在提示是否接受许可时，输入<code>y</code>进行回车确认，最后重新输入<code>flutter doctor</code>进行查看。</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ flutter doctorFlutter assets will be downloaded from https:&#x2F;&#x2F;storage.flutter-io.cn&#x2F;. Make sure you trust this source!Doctor summary (to see all details, run flutter doctor -v):[√] Flutter     (Channel stable, 3.0.5, on Microsoft Windows [版本 10.xxx], locale zh-CN)[!] Android toolchain - develop for Android devices (Android SDK version 33.0.0)    X cmdline-tools component is missing      Run &#96;path&#x2F;to&#x2F;sdkmanager --install &quot;cmdline-tools;latest&quot;&#96;      See https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;command-line for more details.    X Android license status unknown.      Run &#96;flutter doctor --android-licenses&#96; to accept the SDK licenses.      See https:&#x2F;&#x2F;flutter.dev&#x2F;docs&#x2F;get-started&#x2F;install&#x2F;windows      # android-setup for more details.[√] Chrome - develop for the web[√] Visual Studio - develop for Windows (Visual Studio Community 2022 17.3.0)[√] Android Studio (version 2021.2)[√] Connected device (2 available)[√] HTTP Host Availability! Doctor found issues in 1 categories.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-首次创建项目"><a href="#4-首次创建项目" class="headerlink" title="4 首次创建项目"></a>4 首次创建项目</h1><ul><li>首次创建项目<ul><li>启动Android Studio—&gt;New Flutter Project—&gt;Flutter—&gt;Flutter SDK path。</li><li>Flutter SDK path即Flutter SDK的安装路径—&gt;Next—&gt;Project Name项目命名。</li><li>将Project Name命名为<code>myflutter</code>(即Organization包名)—&gt;Finish—&gt;Create。</li></ul></li><li>在该项目上运行程序：File—&gt;Open—&gt;定位到该项目的Android目录—&gt;选中—&gt;OK—&gt;将其打开。</li><li>Sync project with Gradle Files下载：项目打开Android目录时自动下载(位于Android Studio-&gt;File中)。</li><li>No Device Selected：找不到运行设备，两调试方式(命令窗口下<code>flutter devices</code>检测当前可用设备)。<ul><li>Android真机调试<ul><li>手机使用USB数据线连接电脑，开启调试模式，Android Studio安装与手机对应的SDK版本。</li><li>Android Studio—&gt;Tools—&gt;SDK Manager—&gt;SDK Platforms—&gt;勾选对应版本SDK—&gt;OK。</li><li>当No Device Selected变为对应手机型号名称时，Run—&gt;Run‘app’即可在手机中运行程序。</li></ul></li><li>模拟器调试：Android Studio—&gt;Tools—&gt;Device Manager—&gt;启动之前设置好的Android模拟器。</li></ul></li><li>多台设备同时兼容性调试，命令窗口进入对应项目<code>myflutter</code>中，输入<code>flutter run -d all</code>执行程序。</li><li>改完代码之后，不需要重新输入命令执行程序，以下通用快捷键可帮助日常开发。<ul><li>使用热加载<code>Shift + R</code>或<code>r</code>，重新加载程序。</li><li>若热加载没生效，则使用命令<code>R</code>进行热重启。</li><li>命令<code>p</code>显示网格，可以很好地掌握布局情况。</li><li>命令<code>o</code>支持切换Android以及iOS的预览模式。</li><li>命令<code>q</code>退出调试预览模式，相当于<code>Ctrl + C</code>。</li></ul></li></ul><h1 id="5-项目简单介绍"><a href="#5-项目简单介绍" class="headerlink" title="5 项目简单介绍"></a>5 项目简单介绍</h1><ul><li>创建Flutter项目的两种方式<ul><li>Android Studio(正式项目建议使用编辑器来创建)。</li><li>通过命令<code>flutter create &lt;project-name&gt;</code>创建。</li></ul></li><li>目录结构<ul><li>test：用于存放测试代码。</li><li>android、ios、web、windows等：各个平台的资源文件。</li><li>lib：flutter相关代码，开发的所有代码都放在该目录下。</li><li>pubspec.yaml：存放项目第三方依赖、版本号和配置信息等。</li><li>analysis_options.yaml：分析Dart语法的文件，老项目升级新项目时若有警告信息，可删除此文件。</li></ul></li></ul><h2 id="5-1-入口方法"><a href="#5-1-入口方法" class="headerlink" title="5-1 入口方法"></a>5-1 入口方法</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 引入material主题import &#39;package:flutter&#x2F;material.dart&#39;;&#x2F;&#x2F; 入口方法void main() &#123;  &#x2F;&#x2F; Center组件，让内容居中  runApp(const Center(    &#x2F;&#x2F; 查看底层代码使用“Ctrl+鼠标左键”    child: Text(&#39;Hello Flutter!&#39;,      &#x2F;&#x2F; ltr从右向左      textDirection: TextDirection.ltr,      &#x2F;&#x2F; 改变文本样式      style: TextStyle(        &#x2F;&#x2F; color: Colors.red,        color: Color.fromRGBO(80, 120, 35, 1),        fontSize: 27,      ),    ),  ),);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-必须组件"><a href="#5-2-必须组件" class="headerlink" title="5-2 必须组件"></a>5-2 必须组件</h2><ul><li>开发中必须使用的装饰组件：MaterialApp(一般作为顶层Widget使用)、Scaffold(布局结构的基本实现)。</li><li>MaterialApp组件的常用属性：home(主页)、title(标题)、color(颜色)、theme(主题)、routes(路由)等。</li><li>Scaffold组件的常用属性<ul><li>appBar：显示在界面顶部的标题栏。</li><li>body：当前界面所显示的主要内容。</li><li>drawer：抽屉菜单控件，例如左拉、右拉、弹出对话框等。</li></ul></li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;package:flutter&#x2F;material.dart&#39;;void main() &#123;  runApp(MaterialApp(    home: Scaffold(      appBar: AppBar(title: const Text(&#39;必须组件&#39;)),      body: const Center(        child: Text(&#39;Hello Flutter!&#39;,          textDirection: TextDirection.ltr,          style: TextStyle(            color: Colors.red,            &#x2F;&#x2F; color: Color.fromRGBO(80, 120, 35, 1),            fontSize: 27,          ),        ),      ),    ),  ),);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-内容抽离"><a href="#5-3-内容抽离" class="headerlink" title="5-3 内容抽离"></a>5-3 内容抽离</h2><ul><li>Flutter自定义组件即一个类，需集成StatelessWidget或StatefulWidget。</li><li>StatelessWidget是无状态组件，状态不可变的Widget，前期接触比较多。</li><li>StatefulWidget是有状态组件，持有的状态可能在Widget生命周期中改变。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;package:flutter&#x2F;material.dart&#39;;void main() &#123;  runApp(MaterialApp(    home: Scaffold(      appBar: AppBar(title: const Text(&#39;内容抽离&#39;)),      &#x2F;&#x2F; 调用MyApp组件      body: const MyApp(),    ),  ),);&#125;class MyApp extends StatelessWidget &#123;  &#x2F;&#x2F; 常量构造函数    const MyApp(&#123;Key? key&#125;): super(key: key);  @override  Widget build(BuildContext context) &#123;    return const Center(      child: Text(&#39;Flutter自定义组件&#39;,        textDirection: TextDirection.ltr,        style: TextStyle(          &#x2F;&#x2F; color: Colors.red,          color: Color.fromRGBO(80, 120, 35, 1),          fontSize: 27,        ),      ),    );  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/posts/dart@06.html"/>
      <url>/posts/dart@06.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Dart面向对象编程(OOP)是一种将代码组织成对象的编程范式，每个对象都包含数据和行为，类似于现实世界中的实体。</div><h1 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h1><ul><li>面向对象编程OOP的三个基本特征</li><li>封装：把客观事物封装成抽象的类，并把自己的部分属性和方法提供给其他对象。</li><li>继承：可使用现有类的功能，并在无需重新编写原来类的情况下对功能进行扩展。</li><li>多态：允许将子类类型的指针赋值给父类类型的指针，同一个函数调用会有不同的执行效果。</li></ul><h1 id="2-类的创建"><a href="#2-类的创建" class="headerlink" title="2 类的创建"></a>2 类的创建</h1><ul><li>Dart中一切皆对象，所有的对象都继承自Object类，一个类通常由属性和方法组成。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; Person类的创建class Person &#123;  &#x2F;&#x2F; 类的属性  String name &#x3D; &#39;张三&#39;;  int age &#x3D; 21;  &#x2F;&#x2F; 类的方法  void getInfo() &#123;    print(&#39;$name --- $age&#39;);    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;  void setInfo(int age) &#123;    this.age &#x3D; age;  &#125;&#125;void main() &#123;  &#x2F;&#x2F; 实例化Person类  var p1 &#x3D; new Person();  &#x2F;&#x2F; 调用属性  print(p1.name);  &#x2F;&#x2F; 调用方法  p1.getInfo();  Person p2 &#x3D; new Person();  &#x2F;&#x2F; print(p2.name);  p2.setInfo(22);  p2.getInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3 构造函数"></a>3 构造函数</h1><ul><li>Dart中的4种构造函数</li><li>普通构造函数：<code>ClassName(...)</code>，分为无参构造函数和有参构造函数。</li><li>命名构造函数：<code>ClassName.identifier(...)</code>，支持一个类实现多个构造函数，不能重载。</li><li>常量构造函数：<code>const ClassName(...)</code>，如果生成类的对象不变，可以定义常量构造函数。</li><li>工厂构造函数：<code>factory ClassName(...)</code>，factory关键字可以放在类名函数和命名函数前。</li></ul><h2 id="3-1-无参构造函数"><a href="#3-1-无参构造函数" class="headerlink" title="3-1 无参构造函数"></a>3-1 无参构造函数</h2><ul><li>如果不声明构造函数，则Dart会提供一个默认的无参构造函数。</li><li>若自定义有参构造函数，那么默认的无参构造函数就不存在了。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name &#x3D; &#39;张三&#39;;  int age &#x3D; 21;  &#x2F;&#x2F; 构造函数，该方法在实例化时触发  Person() &#123;    print(&#39;无参构造函数&#39;);  &#125;  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;void main() &#123;  &#x2F;&#x2F; 实例化  Person p &#x3D; new Person();  &#x2F;&#x2F; p.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-有参构造函数"><a href="#3-2-有参构造函数" class="headerlink" title="3-2 有参构造函数"></a>3-2 有参构造函数</h2><ul><li>实现的功能：在构造函数中，可以动态地给类指定属性。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  &#x2F;&#x2F; 有参构造函数，提供语法糖简化  String name &#x3D; &#39;&#39;;  int age &#x3D; 0;  &#x2F;&#x2F; 自定义构造函数  &#x2F;&#x2F; Person(String name, int age) &#123;  &#x2F;&#x2F;   this.name &#x3D; name;  &#x2F;&#x2F;   this.age &#x3D; age;  &#x2F;&#x2F; &#125;  &#x2F;&#x2F; 构造函数的简写  Person(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;void main() &#123;  &#x2F;&#x2F; 实例化  Person p1 &#x3D; new Person(&#39;张三&#39;, 21);  p1.printInfo();  Person p2 &#x3D; new Person(&#39;李四&#39;, 22);  p2.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-命名构造函数"><a href="#3-3-命名构造函数" class="headerlink" title="3-3 命名构造函数"></a>3-3 命名构造函数</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  &#x2F;&#x2F; 空安全机制，默认情况下所有变量都必须在声明时被初始化，不能为null  String name &#x3D; &#39;&#39;;  int age &#x3D; 0;  &#x2F;&#x2F; 命名构造函数  Person.now() &#123;    print(&#39;命名构造函数&#39;);  &#125;  Person.setInfo(String name, int age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;  &#125;  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;void main() &#123;  Person p1 &#x3D; new Person.now();  Person p2 &#x3D; new Person.setInfo(&#39;张三&#39;, 21);  p2.printInfo();  &#x2F;&#x2F; 实例化DateTime调用它的命名构造函数  var d &#x3D; new DateTime.now();  print(d);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-类模块化"><a href="#4-类模块化" class="headerlink" title="4 类模块化"></a>4 类模块化</h1><ul><li>将创建的类放在单独的文件夹下，例如：Person类，放在/lib/Person.dart中。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name &#x3D; &#39;&#39;;  int age &#x3D; 0;  Person(this.name, this.age);  Person.now() &#123;    print(&#39;命名构造函数&#39;);  &#125;  Person.setInfo(String name, int age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;  &#125;  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在另一个文件中调用该Person类，则需要导入该类的类文件名。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;.&#x2F;lib&#x2F;Person.dart&#39;;void main() &#123;  Person p &#x3D; new Person.setInfo(&#39;张三&#39;, 21);  p.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-1-私有属性"><a href="#4-1-私有属性" class="headerlink" title="4-1 私有属性"></a>4-1 私有属性</h2><ul><li>在Dart中没有public、private protected等访问修饰符，但可以使用<code>_</code>将属性和方法私有化。</li><li>自定义私有属性，或自定义私有方法时，必须将其单独抽类到一个文件中，这样才有效果。</li><li>例如：Animal类，定义name为私有属性，将创建的Animal类放入/lib/AnimalProperties.dart。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Animal &#123;  &#x2F;&#x2F; 私有属性name  String _name;  int age;    Animal(this._name, this.age);    void printInfo() &#123;    print(&#39;$&#123;this._name&#125; --- $&#123;this.age&#125;&#39;);  &#125;    &#x2F;&#x2F; 公有方法  String getName() &#123;    &#x2F;&#x2F; 私有属性name只在当前类中使用    return this._name;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name私有属性只在当前的Animal类中使用，此时main()函数无法访问Animal类中的私有属性name。</li><li>name私有属性在Animal类的getName()公有方法中，可通过访问公有方法间接地使用私有属性name。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;.&#x2F;lib&#x2F;AnimalProperties.dart&#39;;void main() &#123;  Animal a &#x3D; new Animal(&#39;小狗&#39;, 100);  &#x2F;&#x2F; 无法访问私有属性  &#x2F;&#x2F; print(a._name);  print(a.age);  &#x2F;&#x2F; 访问公有方法来访问私有属性  print(a.getName());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-私有方法"><a href="#4-2-私有方法" class="headerlink" title="4-2 私有方法"></a>4-2 私有方法</h2><ul><li>例如：Animal类，定义run()为私有方法，将创建的Animal类放在/lib/AnimalMethods.dart中。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Animal &#123;  String name;  int age;  Animal(this.name, this.age);  &#x2F;&#x2F; 私有方法  void _run() &#123;    print(&#39;私有方法&#39;);  &#125;  &#x2F;&#x2F; 公有方法  execRun() &#123;    &#x2F;&#x2F; 类里面方法的相互调用    this._run();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>run()私有方法在Animal类的execRun()公有方法中，可通过访问公有方法间接地访问私有方法run()。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;.&#x2F;lib&#x2F;AnimalMethods.dart&#39;;void main() &#123;  Animal a &#x3D; new Animal(&#39;小狗&#39;, 100);  &#x2F;&#x2F; 间接地调用私有方法  a.execRun();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-getter与setter"><a href="#4-3-getter与setter" class="headerlink" title="4-3 getter与setter"></a>4-3 getter与setter</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Rect &#123;  num height;  num width;  Rect(this.height, this.width);  get area &#123;    return this.height * this.width;  &#125;  set areaHeight(value) &#123;    this.height &#x3D; value;  &#125;&#125;void main() &#123;  Rect r &#x3D; new Rect(10, 3);  &#x2F;&#x2F; 通过访问属性来访问area  print(&#39;面积：$&#123;r.area&#125;&#39;);  r.areaHeight &#x3D; 6;  print(&#39;面积：$&#123;r.area&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-类的初始化列表"><a href="#4-4-类的初始化列表" class="headerlink" title="4-4 类的初始化列表"></a>4-4 类的初始化列表</h2><ul><li>可以在构造函数体运行之前初始化实例变量。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Rect &#123;  int height;  int width;  &#x2F;&#x2F; 初始化实例变量  Rect(): height &#x3D; 30, width &#x3D; 10 &#123;    print(&#39;长为：$&#123;this.height&#125;\n宽为：$&#123;this.width&#125;&#39;);  &#125;  getArea() &#123;    return this.height * this.width;  &#125;&#125;void main() &#123;  Rect r &#x3D; new Rect();  print(&#39;面积：$&#123;r.getArea()&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5-类中的静态成员"><a href="#4-5-类中的静态成员" class="headerlink" title="4-5 类中的静态成员"></a>4-5 类中的静态成员</h2><ul><li>通过使用static关键字，来实现类级别的变量以及函数。</li><li>静态属性与静态方法通过类名访问，而非类的实例访问。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  static String name &#x3D; &#39;张三&#39;;  static void show() &#123;    print(name);  &#125;&#125;main() &#123;  &#x2F;&#x2F; var p &#x3D; new Person();  &#x2F;&#x2F; p.show();  print(Person.name);  &#x2F;&#x2F; 调用静态方法  Person.show();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-6-静态非静态比较"><a href="#4-6-静态非静态比较" class="headerlink" title="4-6 静态非静态比较"></a>4-6 静态非静态比较</h2><ul><li>非静态方法可以直接访问静态成员、静态方法，以及非静态成员。</li><li>静态方法能访问静态成员和静态方法，不能访问非静态成员和非静态方法。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  static String name &#x3D; &#39;张三&#39;;  int age &#x3D; 21;  static void show() &#123;    print(name);  &#125;  void printInfo() &#123;    &#x2F;&#x2F; 访问非静态属性    print(this.age);    &#x2F;&#x2F; 访问静态属性    print(name);    &#x2F;&#x2F; 调用静态方法    show();  &#125;  static void printUserInfo() &#123;    &#x2F;&#x2F; 访问静态属性    print(name);    &#x2F;&#x2F; 调用静态方法    show();    &#x2F;&#x2F; 无法访问非静态属性    &#x2F;&#x2F; print(age);    &#x2F;&#x2F; print(this.age);    &#x2F;&#x2F; 无法访问非静态方法    &#x2F;&#x2F; printInfo();    &#x2F;&#x2F; this.printInfo();  &#125;&#125;main() &#123;  Person p &#x3D; new Person();  p.printInfo();  Person.printUserInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-类的继承"><a href="#5-类的继承" class="headerlink" title="5 类的继承"></a>5 类的继承</h1><ul><li>子类使用extends关键词来继承父类，子类能复写父类的方法。</li><li>子类会继承父类里面可见的属性和方法，但不会继承构造函数。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name &#x3D; &#39;张三&#39;;  num age &#x3D; 21;  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;&#x2F;&#x2F; 可以访问Person中共有的属性和方法class Web extends Person &#123;&#125;main() &#123;  &#x2F;&#x2F; 实例化Web类  Web w &#x3D; new Web();  print(w.name);  w.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-1-super关键词"><a href="#5-1-super关键词" class="headerlink" title="5-1 super关键词"></a>5-1 super关键词</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  num age;  Person(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;class Web extends Person &#123;  &#x2F;&#x2F; super表示实例化子类时，将传过来的name和age参数赋值给父类Person  Web(String name, num age): super(name, age) &#123;&#125;&#125;main() &#123;  Web w &#x3D; new Web(&#39;张三&#39;, 21);  w.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-子类扩展属性和方法"><a href="#5-2-子类扩展属性和方法" class="headerlink" title="5-2 子类扩展属性和方法"></a>5-2 子类扩展属性和方法</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  num age;  Person(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;class Web extends Person &#123;  &#x2F;&#x2F; 定义子类自己的属性  String sex;  Web(String name, num age, this.sex): super(name, age);  &#x2F;&#x2F; 定义子类自己的方法  run() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125; --- $&#123;this.sex&#125;&#39;);  &#125;&#125;main() &#123;  Web w &#x3D; new Web(&#39;张三&#39;, 21, &#39;男&#39;);  w.printInfo();  w.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-给命名构造函数传参"><a href="#5-3-给命名构造函数传参" class="headerlink" title="5-3 给命名构造函数传参"></a>5-3 给命名构造函数传参</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  num age;  Person(this.name, this.age);  &#x2F;&#x2F; 命名构造函数  Person.construct(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;class Web extends Person &#123;  String sex;  Web(String name, num age, this.sex): super.construct(name, age);    run() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125; --- $&#123;this.sex&#125;&#39;);  &#125;&#125;main() &#123;  Web w &#x3D; new Web(&#39;张三&#39;, 21, &#39;男&#39;);  w.printInfo();  w.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-子类覆写父类的方法"><a href="#5-4-子类覆写父类的方法" class="headerlink" title="5-4 子类覆写父类的方法"></a>5-4 子类覆写父类的方法</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  num age;  Person(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;  work() &#123;    print(&#39;$&#123;this.name&#125;在工作&#39;);  &#125;&#125;class Web extends Person &#123;  Web(String name, num age): super(name, age);  &#x2F;&#x2F; 子类中扩展方法  run() &#123;    print(&#39;run&#39;);  &#125;  &#x2F;&#x2F; 覆写父类的方法，不加@override也可以，建议加上  @override  void printInfo() &#123;    print(&#39;姓名：$&#123;this.name&#125; --- 年龄：$&#123;this.age&#125;&#39;);  &#125;  @override  work() &#123;    print(&#39;姓名：$&#123;this.name&#125; --- 工作：写代码&#39;);  &#125;&#125;main() &#123;  &#x2F;&#x2F; 实例化子类  Web w &#x3D; new Web(&#39;张三&#39;, 21);  w.printInfo();  w.work();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5-子类中调用父类方法"><a href="#5-5-子类中调用父类方法" class="headerlink" title="5-5 子类中调用父类方法"></a>5-5 子类中调用父类方法</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  num age;  Person(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;  work() &#123;    print(&#39;$&#123;this.name&#125;：工作 --- &#39;);  &#125;&#125;class Web extends Person &#123;  Web(String name, num age): super(name, age);  &#x2F;&#x2F; 子类中扩展方法  run() &#123;    print(&#39;程序：执行 --- &#39;);    &#x2F;&#x2F; 子类调用父类方法    super.work();  &#125;  @override  void printInfo() &#123;    print(&#39;姓名：$&#123;this.name&#125; --- 年龄：$&#123;this.age&#125;&#39;);  &#125;&#125;main() &#123;  &#x2F;&#x2F; 实例化子类  Web w &#x3D; new Web(&#39;张三&#39;, 21);  w.printInfo();  w.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-抽象类与泛型"><a href="#6-抽象类与泛型" class="headerlink" title="6 抽象类与泛型"></a>6 抽象类与泛型</h1><ul><li>抽象类主要通过abstract关键词用于定义标准，子类可继承抽象类，也可实现抽象类接口。<ul><li>抽象类不能被实例化，只有继承它的子类可以。</li><li>如果子类继承抽象类，必须实现它的抽象方法。</li><li>没有方法体的方法称之为抽象方法，不能用abstract关键词来声明。</li><li>若把抽象类当接口实现，须先实现抽象类中定义的所有属性和方法。</li></ul></li><li>extends抽象类和implements的区别<ul><li>如果只是把抽象类当做标准，那么就用implements关键词来实现抽象类。</li><li>若要复用抽象类中的方法且用抽象方法约束子类，用extends继承抽象类。</li></ul></li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 定义一个Animal类，要求它的子类必须包含eat方法abstract class Animal &#123;  &#x2F;&#x2F; 抽象方法  eat();  &#x2F;&#x2F; 非抽象方法  printInfo() &#123;    print(&#39;抽象类中的普通方法&#39;);  &#125;&#125;class Dog extends Animal &#123;  @override  eat() &#123;    print(&#39;小狗在吃美味的骨头&#39;);  &#125;&#125;main() &#123;  Dog d &#x3D; new Dog();  d.eat();  d.printInfo();  &#x2F;&#x2F; 抽象类没法直接被实例化，只有继承它的子类才能被实例化  &#x2F;&#x2F; var a &#x3D; new Animal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-1-多态"><a href="#6-1-多态" class="headerlink" title="6-1 多态"></a>6-1 多态</h2><ul><li>多态就是父类定义一个方法不去实现，让继承它的子类去实现，每个子类有不同的表现。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">abstract class Animal &#123;  &#x2F;&#x2F; 抽象方法  eat();&#125;class Dog extends Animal &#123;  @override  eat() &#123;    print(&#39;小狗在吃美味的骨头&#39;);  &#125;&#125;class Cat extends Animal &#123;  @override  eat() &#123;    print(&#39;小猫在吃可爱的老鼠&#39;);  &#125;&#125;main() &#123;  Dog d &#x3D; new Dog();  d.eat();  Cat c &#x3D; new Cat();  c.eat();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-赋值"><a href="#6-2-赋值" class="headerlink" title="6-2 赋值"></a>6-2 赋值</h2><ul><li>允许将子类类型的指针赋值给父类类型的指针，同一个函数调用会有不同的执行效果。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">abstract class Animal &#123;  &#x2F;&#x2F; 抽象方法  eat();&#125;class Dog extends Animal &#123;  @override  eat() &#123;    print(&#39;小狗在吃美味的骨头&#39;);  &#125;  run() &#123;    print(&#39;程序正在执行过程中&#39;);  &#125;&#125;class Cat extends Animal &#123;  @override  eat() &#123;    print(&#39;小猫在吃可爱的老鼠&#39;);  &#125;  run() &#123;    print(&#39;程序正在执行过程中&#39;);  &#125;&#125;main() &#123;  &#x2F;&#x2F; 子类的实例赋值给父类的引用  Animal d &#x3D; new Dog();  d.eat();  Animal c &#x3D; new Cat();  c.eat();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-接口"><a href="#6-3-接口" class="headerlink" title="6-3 接口"></a>6-3 接口</h2><ul><li>Dart的接口没用interface关键字定义，普通类或抽象类都可作为接口，使用implements关键字实现。<ul><li>如果实现接口的类是普通类，那么Dart会将普通类和抽象类里面属性的方法全部覆写一遍。</li><li>抽象类可定义抽象方法，普通类不可，要实现类似于Java接口的方式，一般都会用抽象类。</li></ul></li><li>建议使用抽象类定义接口。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 接口，即约定或叫规范，定义一个DB库，支持MySQLabstract class DB &#123;  &#x2F;&#x2F; 数据库的链接地址  String uri &#x3D; &#39;&#39;;  add(String data);  edit();  delete();&#125;class MySQL implements DB &#123;  @override  String uri;  MySQL(this.uri);  @override  add(String data) &#123;    print(&#39;这是MySQL的add方法：$data&#39;);  &#125;  @override  edit() &#123;    return null;  &#125;  @override  delete() &#123;    return null;  &#125;&#125;main() &#123;  MySQL mysql &#x3D; new MySQL(&#39;127.0.0.1&#39;);  mysql.add(&#39;123456789&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-抽类"><a href="#6-4-抽类" class="headerlink" title="6-4 抽类"></a>6-4 抽类</h2><ul><li>抽类步骤一：lib目录新建一个DB.dart文件。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 接口，即约定或叫规范，DB.dart文件abstract class DB &#123;  &#x2F;&#x2F; 数据库的链接地址  String uri &#x3D; &#39;&#39;;  add(String data);  edit();  delete();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>抽类步骤二：lib目录新建一个MySQL.dart文件，引入DB.dart文件。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;DB.dart&#39;;&#x2F;&#x2F; MySQL.dart文件class MySQL implements DB &#123;  @override  String uri;  MySQL(this.uri);  @override  add(String data) &#123;    print(&#39;这是MySQL的add方法：$data&#39;);  &#125;  @override  edit() &#123;    return null;  &#125;  @override  delete() &#123;    return null;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>抽类步骤三：创建一个Test.dart文件，用于引入MySQL.dart文件。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;lib&#x2F;MySQL.dart&#39;;&#x2F;&#x2F; Test.dart文件main() &#123;  MySQL mysql &#x3D; new MySQL(&#39;127.0.0.1&#39;);  mysql.add(&#39;123456789&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-多接口"><a href="#6-5-多接口" class="headerlink" title="6-5 多接口"></a>6-5 多接口</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 一个类实现多个接口abstract class A &#123;  String name &#x3D; &#39;&#39;;  printA();&#125;abstract class B &#123;  printB();&#125;class C implements A, B &#123;  @override  String name &#x3D; &#39;&#39;;  @override  printA() &#123;    print(&#39;打印A&#39;);  &#125;  @override  printB() &#123;    print(&#39;打印B&#39;);  &#125;&#125;void main() &#123;  C c &#x3D; new C();  c.printA();  c.printB();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-6-mixins"><a href="#6-6-mixins" class="headerlink" title="6-6 mixins"></a>6-6 mixins</h2><ul><li>mixins即混入，指在类中混入其他功能，在Dart中可以使用mixins实现类似多继承的功能。</li><li>使用的条件伴随着Dart版本的变化一直在改变，这里用的是Dart 2.x中使用mixins的条件。</li><li>一个类可以mixins多个mixins类，mixins绝不是继承，也不是接口，而是一种全新的特性。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class A &#123;  String info &#x3D; &#39;这是A&#39;;  void printA() &#123;    print(&#39;A&#39;);  &#125;&#125;class B &#123;  void printB() &#123;    print(&#39;B&#39;);  &#125;&#125;class C with A, B &#123;&#125;void main() &#123;  var c &#x3D; new C();  c.printA();  c.printB();  print(c.info);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-继承自Object"><a href="#1-继承自Object" class="headerlink" title="(1) 继承自Object"></a>(1) 继承自Object</h3><ul><li>作为mixins的类只能继承自Object，不能继承其他类。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  printInfo() &#123;    print(&#39;Person类&#39;);  &#125;&#125;class A extends Person &#123;  String info &#x3D; &#39;这是A&#39;;  void printA() &#123;    print(&#39;A&#39;);  &#125;&#125;class B &#123;  void printB() &#123;    print(&#39;B&#39;);  &#125;&#125;&#x2F;&#x2F; 这里A类继承了Person类，C类mixinsA类时会报错&#x2F;&#x2F; class C with A, B &#123;&#125;void main() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-不能有构造函数"><a href="#2-不能有构造函数" class="headerlink" title="(2) 不能有构造函数"></a>(2) 不能有构造函数</h3><ul><li>作为mixins的类不能有构造函数。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class A &#123;  String info &#x3D; &#39;这是A&#39;;  void printA() &#123;    print(&#39;A&#39;);  &#125;&#125;class B &#123;  &#x2F;&#x2F; 写构造函数会报错  &#x2F;&#x2F; B() &#123;&#125;;  void printB() &#123;    print(&#39;B&#39;);  &#125;&#125;class C with A, B &#123;&#125;void main() &#123;  var c &#x3D; new C();  c.printA();  c.printB();  print(c.info);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-继承与mixins一起"><a href="#3-继承与mixins一起" class="headerlink" title="(3) 继承与mixins一起"></a>(3) 继承与mixins一起</h3><ul><li>继承与mixins一起写的方法。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  Object age;  Person(this.name, this.age);  printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;class A &#123;  String info &#x3D; &#39;这是A&#39;;  void printA() &#123;    print(&#39;A&#39;);  &#125;&#125;class B &#123;  void printB() &#123;    print(&#39;B&#39;);  &#125;&#125;&#x2F;&#x2F; C类具有Person类、A类和B类的功能&#x2F;&#x2F; class C with Person, A, B &#123;&#125;&#x2F;&#x2F; 此时Person类中可以有构造函数class C extends Person with A, B &#123;  C(String name, Object age): super(name, age);&#125;void main() &#123;  var c &#x3D; new C(&#39;张三&#39;, 21);  c.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-顺序不同结果不同"><a href="#4-顺序不同结果不同" class="headerlink" title="(4) 顺序不同结果不同"></a>(4) 顺序不同结果不同</h3><ul><li>注意<code>with A, B</code>或<code>with B, A</code>的顺序，打印出来的内容不一样，后面替换前面。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  Object age;  Person(this.name, this.age);  printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;  &#x2F;&#x2F; 继承与mixins中有同样的方法，with A, B或with B, A的顺序同下  void run() &#123;    print(&#39;Person类执行中&#39;);  &#125;&#125;class A &#123;  String info &#x3D; &#39;这是A&#39;;  void printA() &#123;    print(&#39;A&#39;);  &#125;  void run() &#123;    print(&#39;A执行中&#39;);  &#125;&#125;class B &#123;  void printB() &#123;    print(&#39;B&#39;);  &#125;  void run() &#123;    print(&#39;B执行中&#39;);  &#125;&#125;&#x2F;&#x2F; 注意with A, B或with B, A的顺序，打印内容不一样，后面替换前面class C extends Person with A, B &#123;  C(String name, Object age): super(name, age);&#125;void main() &#123;  var c &#x3D; new C(&#39;张三&#39;, 21);  c.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-mixins的实例类型"><a href="#5-mixins的实例类型" class="headerlink" title="(5) mixins的实例类型"></a>(5) mixins的实例类型</h3><ul><li>mixins的实例类型就是其超类的子类型。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; ignore_for_file: unnecessary_type_checkclass A &#123;  String info &#x3D; &#39;这是A&#39;;  void printA() &#123;    print(&#39;A&#39;);  &#125;&#125;class B &#123;  void printB() &#123;    print(&#39;B&#39;);  &#125;&#125;class C with A, B &#123;&#125;void main() &#123;  var c &#x3D; new C();  print(c is A);  print(c is B);  print(c is C);  var a &#x3D; new A();  print(a is Object);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-7-泛型方法"><a href="#6-7-泛型方法" class="headerlink" title="6-7 泛型方法"></a>6-7 泛型方法</h2><ul><li>泛型即解决类、接口、方法的复用性，以及对不特定数据类型的支持(类型校验)。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 只能返回String类型的数据String getData1(String value) &#123;  return value;&#125;&#x2F;&#x2F; 同时支持返回String类型和int类型，代码冗余String getData2(String value) &#123;  return value;&#125;int getData3(int value) &#123;  return value;&#125;&#x2F;&#x2F; 同时返回String类型和number类型，不指定类型可以解决问题getData4(value) &#123;  return value;&#125;&#x2F;&#x2F; 不指定类型放弃了类型检查，需要实现的是传入什么就返回什么T getData5&lt;T&gt;(T value) &#123;  return value;&#125;void main() &#123;  print(getData5(21));  print(getData5(&#39;张三&#39;));    getData5&lt;int&gt;(22);  getData5&lt;String&gt;(&#39;李四&#39;);  getData5&lt;int&gt;(23);  getData5&lt;String&gt;(&#39;王五&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-8-泛型类定义"><a href="#6-8-泛型类定义" class="headerlink" title="6-8 泛型类定义"></a>6-8 泛型类定义</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class MyList1 &#123;  List list &#x3D; &lt;int&gt;[];  void add(int value) &#123;    this.list.add(value);  &#125;  List getList() &#123;    return list;  &#125;&#125;&#x2F;&#x2F; 定义泛型类class MyList2&lt;T&gt; &#123;  List list &#x3D; &lt;T&gt;[];  void add(T value) &#123;    this.list.add(value);  &#125;  List getList() &#123;    return list;  &#125;&#125;main() &#123;  &#x2F;&#x2F; 创建固定长度的List，这里使用到了泛型  List l1 &#x3D; new List&lt;String&gt;.filled(2, &#39;&#39;);  l1[0] &#x3D; &#39;121&#39;;  l1[1] &#x3D; &#39;张三&#39;;  print(l1);  &#x2F;&#x2F; new关键词可以省略  MyList1 l2 &#x3D; MyList1();  l2.add(123);  l2.add(321);  print(l2.getList());  MyList2 l3 &#x3D; MyList2();  l3.add(125);  l3.add(&#39;李四&#39;);  print(l3.getList());  MyList2 l4 &#x3D; MyList2&lt;String&gt;();  l4.add(&#39;王五&#39;);  &#x2F;&#x2F; 传int会报错  l4.add(&#39;135&#39;);  print(l4.getList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-9-泛型接口定义"><a href="#6-9-泛型接口定义" class="headerlink" title="6-9 泛型接口定义"></a>6-9 泛型接口定义</h2><ul><li>实现数据缓存的功能：文件缓存和内存缓存，这两种功能按接口约束实现。</li><li>定义一个泛型接口<ul><li>约束实现子类必须有<code>getByKey(Key)</code>和<code>setByKey(key, value)</code>。</li><li>要求setByKey的value类型和实例化子类时指定的类型需保持一致。</li></ul></li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 定义一个接口abstract class Cache&lt;T&gt; &#123;  &#x2F;&#x2F; 定义两个抽象方法  getByKey(String key);  void setByKey(String key, T value);&#125;&#x2F;&#x2F; 定义两个类FileCache和MemoryCacheclass FileCache&lt;T&gt; implements Cache&lt;T&gt; &#123;  @override  getByKey(String key) &#123;    return null;  &#125;  @override  void setByKey(String key, T value) &#123;    print(&#39;我是文件缓存，把key&#x3D;$&#123;key&#125;、value&#x3D;$&#123;value&#125;的数据写入到了文件中&#39;);  &#125;&#125;class MemoryCache&lt;T&gt; implements Cache&lt;T&gt; &#123;  @override  getByKey(String key) &#123;    return null;  &#125;  @override  void setByKey(String key, T value) &#123;    print(&#39;我是内存缓存，把key&#x3D;$&#123;key&#125;、value&#x3D;$&#123;value&#125;的数据写入到了内存中&#39;);  &#125;&#125;void main() &#123;  MemoryCache m1 &#x3D; new MemoryCache&lt;String&gt;();  m1.setByKey(&#39;index&#39;, &#39;&#123;姓名: 李四, 工作: 测试&#125;&#39;);  MemoryCache m2 &#x3D; new MemoryCache&lt;Map&gt;();  m2.setByKey(&#39;index&#39;, &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;工作&#39;: &#39;码农&#39;&#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数说明</title>
      <link href="/posts/dart@05.html"/>
      <url>/posts/dart@05.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Dart函数是代码的构建块，用于执行特定的任务，并返回值，将代码逻辑划分为独立的功能模块，提高可读性和可维护性。</div><h1 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h1><ul><li>函数即方法，内置的方法，例如：<code>print()</code>。</li><li>自定义方法，格式：<code>返回类型 方法名称(参数1, 参数2, ..., 参数n) &#123; &#125;</code>。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 全局作用域void printInfo() &#123;  print(&#39;全局作用域&#39;);  printGlobal() &#123;    print(&#39;局部作用域&#39;);  &#125;  &#x2F;&#x2F; 局部作用域只在局部调用  printGlobal();&#125;void main() &#123;  print(&#39;内置方法&#39;);  &#x2F;&#x2F; 调用方法  printInfo();  &#x2F;&#x2F; 全局作用域  int getNum() &#123;    var myNum &#x3D; 12345678;    return myNum;  &#125;  &#x2F;&#x2F; 调用方法  var n &#x3D; getNum();  print(n);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 定义一个方法，求1到这个数的所有数之和  int sumNum(int n) &#123;    var sum &#x3D; 0;    for(var i&#x3D;1; i&lt;&#x3D;n; i++) &#123;      sum +&#x3D; i;    &#125;    return sum;  &#125;  var n &#x3D; sumNum(20);  print(n);  &#x2F;&#x2F; 定义一个方法，然后打印用户信息  &#x2F;&#x2F; 方法传参：形参  String printUserInfo(String username, int age) &#123;    return &#39;姓名：$username --- 年龄：$age&#39;;  &#125;  &#x2F;&#x2F; 方法传参：实参  print(printUserInfo(&#39;张三&#39;, 21));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-1-可选参数"><a href="#2-1-可选参数" class="headerlink" title="2-1 可选参数"></a>2-1 可选参数</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 定义一个方法，该方法带可选参数：[Data type Variable]  String printUserInfo(String username, [int age &#x3D; 0]) &#123;    if(age !&#x3D; null) &#123;      return &#39;姓名：$username --- 年龄：$age&#39;;    &#125;    return &#39;姓名：$username --- 年龄：保密&#39;;  &#125;  &#x2F;&#x2F; 方法传参：实参  print(printUserInfo(&#39;张三&#39;, 21));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-默认参数"><a href="#2-2-默认参数" class="headerlink" title="2-2 默认参数"></a>2-2 默认参数</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 定义一个方法，该方法带默认参数：[Data type Variable &#x3D; &#39;Default&#39;]  String printUserInfo(String username, [int age &#x3D; 21]) &#123;    if(age !&#x3D; null) &#123;      return &#39;姓名：$username --- 年龄：$age&#39;;    &#125;    return &#39;姓名：$username --- 年龄：保密&#39;;  &#125;  &#x2F;&#x2F; 方法传参：实参  print(printUserInfo(&#39;张三&#39;));  print(printUserInfo(&#39;李四&#39;, 22));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-命名参数"><a href="#2-3-命名参数" class="headerlink" title="2-3 命名参数"></a>2-3 命名参数</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 定义一个方法，该方法带命名参数：&#123;Data type Variable &#x3D; &#39;Default&#39;&#125;  String printUserInfo(String username, &#123;int age &#x3D; 0&#125;) &#123;    if(age !&#x3D; null) &#123;      return &#39;姓名：$username --- 年龄：$age&#39;;    &#125;    return &#39;姓名：$username --- 年龄：保密&#39;;  &#125;  &#x2F;&#x2F; 方法传参：实参  print(printUserInfo(&#39;张三&#39;, age: 21));  &#x2F;&#x2F; 实现一个方法，该方法将另一个方法当作参数传入  fn1() &#123;    print(&#39;将fn1作为一个参数传入fn2&#39;);  &#125;  fn2(fName) &#123;    fName();  &#125;  fn2(fn1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3 箭头函数"></a>3 箭头函数</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 箭头函数：forEach打印List里的数据  List list &#x3D; [&#39;樱桃&#39;, &#39;香蕉&#39;, &#39;苹果&#39;];  list.forEach((element) &#x3D;&gt; print(element));  list.forEach((element) &#x3D;&gt; &#123;print(element)&#125;);  &#x2F;&#x2F; 修改List里的数据，让数组中大于2的值乘以2  List listNum &#x3D; [4, 1, 2, 3, 4];  var newList &#x3D; listNum.map((e) &#123;    if(e &gt; 2) &#123;      return e * 2;    &#125;    return e;  &#125;);  print(newList.toList());  var newListNum &#x3D; listNum.map((e) &#x3D;&gt; e &gt; 2 ? e * 2 : e);  print(newListNum.toList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-相互调用"><a href="#4-相互调用" class="headerlink" title="4 相互调用"></a>4 相互调用</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 定义一个方法，使用isEvenNumber判断一个数是否为偶数  bool isEvenNumber(int n) &#123;    if(n % 2 &#x3D;&#x3D; 0) &#123;      return true;    &#125;    return false;  &#125;  &#x2F;&#x2F; 定义一个方法，打印1-n以内的所有偶数  printNum(int n) &#123;    for(var i&#x3D;1; i&lt;&#x3D;n; i++) &#123;      if(isEvenNumber(i)) &#123;        print(i);      &#125;    &#125;  &#125;  &#x2F;&#x2F; 函数的相互调用  printNum(9);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-匿名函数"><a href="#5-匿名函数" class="headerlink" title="5 匿名函数"></a>5 匿名函数</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 匿名函数  var printNumber &#x3D; ()&#123;    print(123);  &#125;;  printNumber();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-方法递归"><a href="#6-方法递归" class="headerlink" title="6 方法递归"></a>6 方法递归</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 方法递归：条件满足的情况下在方法内调用自身，求1-100的和  var sum &#x3D; 0;  fn(int n) &#123;    sum +&#x3D; n;    if(n &#x3D;&#x3D; 1) &#123;      return;    &#125;    fn(n - 1);  &#125;    fn(100);  print(sum);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-闭包操作"><a href="#7-闭包操作" class="headerlink" title="7 闭包操作"></a>7 闭包操作</h1><ul><li>全局变量特点：常驻内存，污染全局。</li><li>局部变量特点：不常驻内存，支持垃圾机制回收，不污染全局。</li><li>要想实现常驻内存，又不会污染全局，闭包可以解决这些问题。<ul><li>写法：函数嵌套函数，并return里面的函数，这样就形成了闭包。</li><li>说明：内部函数调用外部函数的变量或参数，且这些变量或参数不会被系统回收。</li></ul></li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 闭包  fn() &#123;    var a &#x3D; 123;    return() &#123;      a++;      print(a);    &#125;;  &#125;  var b &#x3D; fn();  b();  b();  b();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-自执行方法"><a href="#8-自执行方法" class="headerlink" title="8 自执行方法"></a>8 自执行方法</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 自执行方法：即不需要调用，自动执行的方法  (() &#123;    print(&#39;自执行方法一&#39;);  &#125;)();  ((String n) &#123;    print(n);  &#125;)(&#39;自执行方法二&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定义 </tag>
            
            <tag> 参数 </tag>
            
            <tag> 匿名 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 高阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程语句</title>
      <link href="/posts/dart@04.html"/>
      <url>/posts/dart@04.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Dart流程语句控制程序执行的流程，根据条件决定执行的代码，或重复执行特定代码块，常用语句有if、else、for、while等。</div><h1 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1 if语句"></a>1 if语句</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; if...else...语句  String today &#x3D; &#39;星期一&#39;;  if(today &#x3D;&#x3D; &#39;星期一&#39;) &#123;    print(&#39;今天星期一&#39;);  &#125; else &#123;    print(&#39;美好的一天&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-switch"><a href="#2-switch" class="headerlink" title="2 switch"></a>2 switch</h1><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; switch...case语句  String today &#x3D; &#39;星期一&#39;;  switch(today) &#123;    case &#39;星期一&#39;:      print(&#39;今天星期一&#39;);      break;    default:      print(&#39;美好的一天&#39;);      break;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-for和while"><a href="#3-for和while" class="headerlink" title="3 for和while"></a>3 for和while</h1><ul><li>第一次循环条件不成立的情况，while循环不执行，do…while循环执行一次。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; for循环  for(int x&#x3D;1; x&lt;&#x3D;3; x++) &#123;    print(&#39;for循环：$x&#39;);  &#125;  &#x2F;&#x2F; while循环  int y &#x3D; 1;  while(y &lt;&#x3D; 3) &#123;    print(&#39;while循环：$y&#39;);    y++;  &#125;  &#x2F;&#x2F; do...while循环  int z &#x3D; 1;  int sum &#x3D; 0;  do &#123;    sum +&#x3D; z;    z++;  &#125; while(z &lt;&#x3D; 3);  print(&#39;do...while循环的和：$sum&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-跳出一层循环"><a href="#4-跳出一层循环" class="headerlink" title="4 跳出一层循环"></a>4 跳出一层循环</h1><ul><li>break用于跳出循环，如果有多层循环，则只能跳出一层循环。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; break跳出循环  for(var i&#x3D;1; i&lt;&#x3D;5; i++) &#123;    if(i &#x3D;&#x3D; 4) &#123;      break;    &#125;    print(i);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-跳出本次循环"><a href="#5-跳出本次循环" class="headerlink" title="5 跳出本次循环"></a>5 跳出本次循环</h1><ul><li>continue用来跳出本次循环。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; continue跳出本次循环  for(var i&#x3D;1; i&lt;&#x3D;3; i++) &#123;    if(i &#x3D;&#x3D; 2) &#123;      continue;    &#125;    print(i);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-其他循环语句"><a href="#6-其他循环语句" class="headerlink" title="6 其他循环语句"></a>6 其他循环语句</h1><ul><li>any(只要集合中有满足条件的数据就返回true)、map(修改集合中的数据)。</li><li>every(集合中的每一个数据都必须满足条件才返回true，否则将返回false)。</li><li>where(返回满足条件的数据)、forEach(循环遍历List)。</li></ul><h2 id="6-1-any"><a href="#6-1-any" class="headerlink" title="6-1 any"></a>6-1 any</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; any  List mylist &#x3D; [1, 3, 5, 7, 9];  var anyList &#x3D; mylist.any((value) &#123;    return value &gt;&#x3D; 5;  &#125;);  print(anyList);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-map"><a href="#6-2-map" class="headerlink" title="6-2 map"></a>6-2 map</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; map  List mylist &#x3D; [1, 2, 3];  var doubleList &#x3D; mylist.map((value) &#123;    return value * 2;  &#125;);  print(doubleList.toList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-every"><a href="#6-3-every" class="headerlink" title="6-3 every"></a>6-3 every</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; every  List mylist &#x3D; [1, 3, 5, 7, 9];  var everyList &#x3D; mylist.every((value) &#123;    return value &gt;&#x3D; 5;  &#125;);  print(everyList);  &#x2F;&#x2F; 循环方法同样适用于set  var s &#x3D; new Set();  s.addAll([11111, 22222, 33333]);  s.forEach((value) &#x3D;&gt; print(value));  &#x2F;&#x2F; 循环方法同样适用于map  var person &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;工作&#39;: &#39;测试&#39;&#125;;  person.forEach((key, value) &#123;    print(&#39;$key --- $value&#39;);  &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-where"><a href="#6-4-where" class="headerlink" title="6-4 where"></a>6-4 where</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; where  List mylist &#x3D; [1, 3, 5, 7, 9];  var newList &#x3D; mylist.where((value) &#123;    return value &gt;&#x3D; 5;  &#125;);  print(newList.toList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-forEach"><a href="#6-5-forEach" class="headerlink" title="6-5 forEach"></a>6-5 forEach</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  List mylist &#x3D; [&#39;樱桃&#39;, &#39;西瓜&#39;, &#39;香蕉&#39;];  for(var i&#x3D;0; i&lt;mylist.length; i++) &#123;    print(&#39;方法一：$&#123;mylist[i]&#125;&#39;);  &#125;  for(var item in mylist) &#123;    print(&#39;方法二：$item&#39;);  &#125;    &#x2F;&#x2F; forEach  mylist.forEach((value) &#123;    print(&#39;forEach：$value&#39;);  &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if </tag>
            
            <tag> switch </tag>
            
            <tag> for </tag>
            
            <tag> while </tag>
            
            <tag> where </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Desktop</title>
      <link href="/posts/docker@01.html"/>
      <url>/posts/docker@01.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Docker是在Linux下的一种容器，支持类似于沙盒环境下的环境搭建、软件安装、软件使用、程序编码等操作。</div><h1 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1 简单介绍"></a>1 简单介绍</h1><ul><li>镜像Image：类似于虚拟机里的镜像（<code>.ISO</code>)，只读模板，独立的文件系统，可用来创建新的容器。</li><li>容器Container<ul><li>是由Docker镜像创建的运行实例，类似于VM虚拟机，支持启动、停止、删除等操作。</li><li>每个容器间相互隔离，容器中可运行特定应用，包含特定应用代码及所需的依赖文件。</li></ul></li><li>仓库Repository：镜像商店，用于传播镜像的地方。<ul><li>官方仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a>。</li><li>国内仓库：<a href="https://hub.daocloud.io/">https://hub.daocloud.io/</a>。</li></ul></li></ul><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1-1 安装"></a>1-1 安装</h2><ul><li>傻瓜式安装后，重启电脑：<a href="https://docs.docker.com/desktop/install/windows-install/">Docker Desktop for Windows</a>。</li><li>双击桌面的“Docker Desktop”图标，启动Docker Desktop。</li><li>如果弹窗提示“Docker Desktop requires a newer WSL kernel version”。</li><li>则以管理员身份打开PowerShell，输入命令<code>wsl --update</code>进行WSL升级。</li></ul><h2 id="1-2-换源"><a href="#1-2-换源" class="headerlink" title="1-2 换源"></a>1-2 换源</h2><ul><li>国内从DockerHub拉取镜像时网速慢，可配置镜像加速器加速，很多云服务商都提供了国内加速器服务。</li><li>Docker Desktop&gt;Settings&gt;Docker Engine&gt;在<code>builder</code>前增加如下内容&gt;点击<code>Apply &amp; restart</code>按钮。</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;registry-mirrors&quot;: [    &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;],&quot;insecure-registries&quot;: [],&quot;debug&quot;: true,&quot;experimental&quot;: false,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-验证"><a href="#1-3-验证" class="headerlink" title="1-3 验证"></a>1-3 验证</h2><ul><li>命令窗口输入<code>docker run hello-world</code>，查看docker是否会从官方仓库中拉取hello-world镜像到本地。</li><li>并自动将其实例化成容器，成功则说明镜像加速器配置正确，Docker Desktop的Containers中显示该镜像。</li></ul><h1 id="2-镜像操作"><a href="#2-镜像操作" class="headerlink" title="2 镜像操作"></a>2 镜像操作</h1><ul><li>以下基础操作均支持在PowerShell命令窗口中进行。</li></ul><h2 id="2-1-查看镜像"><a href="#2-1-查看镜像" class="headerlink" title="2-1 查看镜像"></a>2-1 查看镜像</h2><ul><li>REPOSITORY(镜像所在仓库的名称)、TAG(镜像标签)、IMAGE ID(镜像ID)。</li><li>CREATED(镜像的创建日期，而并不是获取该镜像的日期)、SIZE(镜像大小)。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 查看当前所有的镜像(docker images)docker imagesdocker image ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-2-拉取镜像"><a href="#2-2-拉取镜像" class="headerlink" title="2-2 拉取镜像"></a>2-2 拉取镜像</h2><ul><li>官方默认仓库名为library，<code>docker pull &lt;image-name&gt;</code>命令相当于<code>docker pull library/&lt;image-name&gt;</code>。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 拉取官方镜像(docker pull)docker image pull &lt;image-name&gt;docker pull &lt;image-name&gt;docker pull ubuntudocker pull ubuntu:16.04# 拉取个人镜像docker pull &lt;depository-name&gt;&#x2F;&lt;image-name&gt;docker pull xxx&#x2F;flask# 拉取第三方仓库docker pull &lt;3th-depository-url&gt;&#x2F;&lt;depository-name&gt;&#x2F;&lt;image-name&gt;# 默认仓库名为librarydocker pull hub.c.163.com&#x2F;library&#x2F;mysql:latest  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-删除镜像"><a href="#2-3-删除镜像" class="headerlink" title="2-3 删除镜像"></a>2-3 删除镜像</h2><ul><li>删除镜像的前提是没有使用这个镜像的容器，若已使用，需要先删除该镜像下的所有容器。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 删除镜像(docker rmi)docker image rm &lt;image-name|image-id&gt;docker rmi &lt;image-name|image-id&gt;docker image rm ubuntudocker rmi 9e64176cd8a2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-创建容器"><a href="#2-4-创建容器" class="headerlink" title="2-4 创建容器"></a>2-4 创建容器</h2><ul><li>run可选参数及作用<ul><li><code>-i</code>：以交互模式运行容器。</li><li><code>-d</code>：创建一个守护式容器在后台运行，该方式不会自动登录容器。</li><li><code>-t</code>：容器启动后进入命令行模式，即创建后立马分配一个伪终端。</li><li><code>-v</code>：目录映射，即宿主机目录做修改，然后共享到容器中。</li><li><code>-p</code><ul><li>端口映射，即将容器中的端口号映射到宿主机的端口号中。</li><li>例<code>-p 8080:80</code>将容器的80端口映射到宿主机的8080端口。</li></ul></li><li><code>--name</code>：为创建的容器命名，默认随机命名，不支持中文命名。</li><li><code>--network=host</code><ul><li>将宿主机的网络环境映射到容器中，使得容器的网络与宿主机相同。</li><li>适用于需要容器与宿主机共享网络资源的场景(环境相同存在风险)。</li></ul></li></ul></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 创建容器(docker run)docker run [-i|-d|-t|-v|-p|--name|--network&#x3D;host] &lt;image-name&gt; [command]# 启动linux的一个发行版kali系统docker run -idt --name&#x3D;kali-test kalilinux&#x2F;kali-rollingdocker run -i -d -t --name&#x3D;kali-test kalilinux&#x2F;kali-rolling# 启动网站，本地http:&#x2F;&#x2F;localhost:8080&#x2F;查看docker run -dp 8080:80 --name docker-test docker&#x2F;getting-started<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-交互式容器"><a href="#3-交互式容器" class="headerlink" title="3 交互式容器"></a>3 交互式容器</h1><ul><li>创建容器时使用的命令都加入了<code>-d</code>参数，让容器在后台运行，接下来介绍与正运行的容器进行交互的操作。</li></ul><h2 id="3-1-查看容器"><a href="#3-1-查看容器" class="headerlink" title="3-1 查看容器"></a>3-1 查看容器</h2><ul><li>CONTAINER ID(镜像ID)、IMAGE(镜像名)、COMMAND(默认启动命令)。</li><li>CREATED(创建容器的日期)、STATUS(当前的状态)、PORTS(映射端口)。</li><li>NAMES(容器名称)、SIZE(容器大小)。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">docker ps                       # 查看当前所有正在运行的容器(docker ps)docker ps -a                    # 查看当前所有的容器docker ps -f name&#x3D;&lt;NAMES&gt;       # 使用name过滤器docker ps -f id&#x3D;&lt;CONTAINER ID&gt;  # 使用id过滤器docker ps -f STATUS&#x3D;exited      # 所有停止的容器过滤docker ps -f STATUS&#x3D;running     # 所有正在运行的容器过滤docker ps -n &lt;n&gt;                # 显示n个上次创建的容器docker ps -n 2                  # 显示2个上次创建的容器docker ps -l                    # 显示最新创建的容器docker ps -q                    # 仅显示CONTAINER IDdocker ps -s                    # 显示容器大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-启动容器"><a href="#3-2-启动容器" class="headerlink" title="3-2 启动容器"></a>3-2 启动容器</h2><ul><li>如果成功启动容器，会返回容器ID。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 启动容器docker start &lt;container-name|container-id&gt;docker container start &lt;container-name|container-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-3-关闭容器"><a href="#3-3-关闭容器" class="headerlink" title="3-3 关闭容器"></a>3-3 关闭容器</h2><ul><li>如果成功关闭容器，会返回容器ID。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 关闭容器docker stop &lt;container-name|container-id&gt;docker container stop &lt;container-name|container-id&gt;# 强制关闭容器docker kill &lt;container-name|container-id&gt;docker container kill &lt;container-name|container-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3-4 删除容器"></a>3-4 删除容器</h2><ul><li>删除容器需要确保该容器已经停止，正在运行的容器无法直接删除。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 删除容器docker rm &lt;container-name|container-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-5-后台容器"><a href="#3-5-后台容器" class="headerlink" title="3-5 后台容器"></a>3-5 后台容器</h2><ul><li>需要先确保操作的容器是开启状态的，以先前启动的linux发行版kali系统为例。</li><li>exec可选参数及作用<ul><li><code>-i</code>：以交互模式运行容器。</li><li><code>-d</code>：创建一个守护式容器在后台运行，该方式不会自动登录容器。</li><li><code>-t</code>：容器启动后进入命令行模式，即创建后立马分配一个伪终端。</li><li><code>-e</code>：设置环境变量。</li><li><code>-u</code>：设置用户名和UID。</li><li><code>-w</code>：设置容器内的工作目录。</li></ul></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">docker exec -it &lt;container-name|container-id&gt; &lt;command&gt;# 查看kali-test容器的有效用户名docker exec -it kali-test whoami# 根据Linux特性启动bash命令行docker exec -it kali-test &#x2F;bin&#x2F;bashdocker attach &lt;container-name|container-id&gt;# 附着到正在运行的容器上docker attach kali-test                                                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-镜像制作"><a href="#3-6-镜像制作" class="headerlink" title="3-6 镜像制作"></a>3-6 镜像制作</h2><ul><li>打包备份的文件会自动存放在当前命令行的路径下，如果想让保存的文件可以打开，则加<code>.tar</code>后缀。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 将容器制作成镜像docker commit &lt;container-name&gt; &lt;image-name&gt;# 镜像打包备份docker save -o &lt;file-name&gt; &lt;image-name&gt;# 镜像解压即可直接使用环境docker load -i &lt;file-path&gt;&#x2F;&lt;backup-file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/posts/dart@03.html"/>
      <url>/posts/dart@03.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Dart数据类型定义了变量可以存储的值类型，包括数字、字符串、布尔、字典、列表、映射以及其他特殊类型等。</div><h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h1><ul><li>常用类型<ul><li>数字(Number)：<code>int</code>关键字(整型)、<code>double</code>关键字(浮点型)。</li><li>布尔(Boolean)：<code>bool</code>关键字。</li><li>字典(Map)：键和值可以是任何类型的对象。</li><li>数组(List)：Dart中是列表对象，大多数人称之为列表。</li><li>集合(Set)：Dart中Set是一个元素唯一并且无序的集合。</li><li>字符串(String)：<code>String</code>关键字，开发过程中大量使用。</li></ul></li><li>不常用类型<ul><li>Runes：表示字符串中的UTF-32编码字符。</li><li>Symbol：指Dart程序中声明的运算符或标识符。</li></ul></li></ul><h1 id="2-数字"><a href="#2-数字" class="headerlink" title="2 数字"></a>2 数字</h1><ul><li>int整型和double浮点型，都是Number类型的子类，int类型不能包含小数点。</li><li>包含<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>以及位移操作等，常用的方法有abs、ceil和floor。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; int，必须是整型  int num1 &#x3D; 123;  print(&#39;整型：$num1&#39;);  &#x2F;&#x2F; double，既可以是整型，也可以是浮点型  double num2 &#x3D; 123;  double num3 &#x3D; 123.5;  print(&#39;浮点型：$num2&#39;);  print(&#39;浮点型：$num3&#39;);    &#x2F;&#x2F; 运算符操作  var sum &#x3D; num1 + num2;  print(&#39;运算符操作：$sum&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-布尔"><a href="#3-布尔" class="headerlink" title="3 布尔"></a>3 布尔</h1><ul><li>只有字面量true和false是布尔类型，这两个对象都是编译时常量。</li><li>Dart是强布尔类型检查，只有bool类型的值是true才被认为是true。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 布尔类型  bool flag1 &#x3D; true;  print(&#39;布尔类型：$flag1&#39;);  bool flag2 &#x3D; false;  print(&#39;布尔类型：$flag2&#39;);  &#x2F;&#x2F; 条件判断语句  var flag &#x3D; false;  if(flag) &#123;    print(&#39;布尔类型：true&#39;);  &#125; else &#123;    print(&#39;布尔类型：false&#39;);  &#125;  var a &#x3D; 123;  var b &#x3D; 456;  if(a &#x3D;&#x3D; b) &#123;    print(&#39;条件判断：a &#x3D;&#x3D; b&#39;);  &#125; else &#123;    print(&#39;条件判断：a !&#x3D; b&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-字典"><a href="#4-字典" class="headerlink" title="4 字典"></a>4 字典</h1><ul><li>将key和value关联在一起，也就是键值对，且key必须是唯一的。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; Map定义方式一  var person1 &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;年龄&#39;: 21, &#39;工作&#39;: &#39;程序员&#39;&#125;;  print(&#39;姓名：$&#123;person1[&#39;姓名&#39;]&#125;&#39;);  print(&#39;方式一：$person1&#39;);  &#x2F;&#x2F; Map定义方式二：构造函数Map()  var person2 &#x3D; new Map();  person2[&#39;姓名&#39;] &#x3D; &#39;李四&#39;;  person2[&#39;年龄&#39;] &#x3D; 22;  person2[&#39;工作&#39;] &#x3D; &#39;设计师&#39;;  print(&#39;方式二：$person2&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-1-添加获取"><a href="#4-1-添加获取" class="headerlink" title="4-1 添加获取"></a>4-1 添加获取</h2><ul><li>可以为Map对象添加新的键值对，通过length获取键值对的数量。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  var person &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;年龄&#39;: 21&#125;;  &#x2F;&#x2F; 添加新的键值对  person[&#39;性别&#39;] &#x3D; &#39;男&#39;;  print(person);    &#x2F;&#x2F; 使用length获取键值对的数量  print(&#39;length获取到的person键值对数量：$&#123;person.length&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-常用属性"><a href="#4-2-常用属性" class="headerlink" title="4-2 常用属性"></a>4-2 常用属性</h2><ul><li>keys(获取key值)、values(获取value值)、isEmpty(是否为空)、isNotEmpty(是否不空)。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 常用属性  Map person &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;年龄&#39;: 21, &#39;性别&#39;: &#39;男&#39;&#125;;  print(&#39;键：$&#123;person.keys&#125;&#39;);  print(&#39;值：$&#123;person.values&#125;&#39;);  print(&#39;是否为空：$&#123;person.isEmpty&#125;&#39;);  print(&#39;是否不空：$&#123;person.isNotEmpty&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-常用方法"><a href="#4-3-常用方法" class="headerlink" title="4-3 常用方法"></a>4-3 常用方法</h2><ul><li>remove()、addAll()(映射拼接)、containsValue(查看映射内的值)。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 常用方法  Map person &#x3D; &#123;&#39;姓名&#39;: &#39;张三&#39;, &#39;年龄&#39;: 21&#125;;  person.addAll(&#123;&#39;性别&#39;: &#39;男&#39;&#125;);  print(person);  person.remove(&#39;性别&#39;);  print(person);  print(&#39;是否包含“张三”：$&#123;person.containsValue(&#39;张三&#39;)&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h1><ul><li>具有一系列相同类型的数据，类似于JavaScript的Array数组对象。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; List定义方式一  var l1 &#x3D; [&#39;张三&#39;, 21, true];  print(&#39;List定义方式一：$l1&#39;);  print(&#39;\tList的长度：$&#123;l1.length&#125;&#39;);  print(&#39;\tList的位置：$&#123;l1[0]&#125;&#39;);  &#x2F;&#x2F; List定义方式二：指定类型  var l2 &#x3D; &lt;int&gt;[21, 23, 25, 27, 29];  var l3 &#x3D; &lt;String&gt;[&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;赵六&#39;];  print(&#39;List定义方式二：$l2&#39;);  print(&#39;List定义方式三：$l3&#39;);  &#x2F;&#x2F; List定义方式三：增加数据  var l4 &#x3D; [];  print(&#39;List定义方式三：$l4&#39;);  print(&#39;\tList的长度：$&#123;l4.length&#125;&#39;);  l4.add(&#39;孙七&#39;);  l4.add(&#39;周八&#39;);  l4.add(&#39;吴九&#39;);  l4.add(&#39;郑十&#39;);  l4.add(30);  print(&#39;List定义方式三：$l4&#39;);  print(&#39;\tList的长度：$&#123;l4.length&#125;&#39;);  &#x2F;&#x2F; List定义方式四：新版中已去除  &#x2F;&#x2F; var l5 &#x3D; new List();  &#x2F;&#x2F; l5.add(&#39;张三&#39;);  &#x2F;&#x2F; l5.add(&#39;李四&#39;);  &#x2F;&#x2F; l5.add(&#39;王五&#39;);  &#x2F;&#x2F; l5.add(&#39;赵六&#39;);  &#x2F;&#x2F; l5.add(&#39;孙七&#39;);  &#x2F;&#x2F; print(&#39;List定义方式四：$l5&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-1-元素索引"><a href="#5-1-元素索引" class="headerlink" title="5-1 元素索引"></a>5-1 元素索引</h2><ul><li>List对象的第一个元素索引是0，最后一个元素索引是<code>list.length-1</code>。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 创建一个固定长度的集合  var l1 &#x3D; List.filled(3, &#39;&#39;);  print(&#39;固定长度的集合：$l1&#39;);  l1[0] &#x3D; &#39;张三&#39;;  l1[1] &#x3D; &#39;李四&#39;;  l1[2] &#x3D; &#39;王五&#39;;  print(&#39;固定长度的集合：$l1&#39;);  &#x2F;&#x2F; 已固定长度，添加Unhandled exception报错  &#x2F;&#x2F; l1.add(&#39;赵六&#39;);  &#x2F;&#x2F; print(&#39;固定长度的集合：$l1&#39;);  &#x2F;&#x2F; 也无法通过修改长度进行改变  &#x2F;&#x2F; l1.length &#x3D; 5;  &#x2F;&#x2F; 该定义方式可以改变集合的长度  var l2 &#x3D; [&#39;孙七&#39;, &#39;周八&#39;];  l2.length &#x3D; 0;  print(&#39;改变集合的长度：$l2&#39;);  var l3 &#x3D; List&lt;String&gt;.filled(3, &#39;&#39;);  l3[0] &#x3D; &#39;字典&#39;;  l3[1] &#x3D; &#39;布尔&#39;;  l3[2] &#x3D; &#39;数组&#39;;  print(&#39;改变集合的长度：$l3&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-常用属性"><a href="#5-2-常用属性" class="headerlink" title="5-2 常用属性"></a>5-2 常用属性</h2><ul><li>length(长度)、reversed(翻转)、isEmpty(为空)、isNotEmpty(不为空)。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 常见属性  var list &#x3D; [&#39;苹果&#39;, &#39;西瓜&#39;];  list.add(&#39;葡萄&#39;);  print(&#39;列表：$list&#39;);  print(&#39;长度：$&#123;list.length&#125;&#39;);  print(&#39;不空：$&#123;list.isNotEmpty&#125;&#39;);  print(&#39;为空：$&#123;list.isEmpty&#125;&#39;);  &#x2F;&#x2F; 翻转后再转换成List  print(&#39;列表：$&#123;list.reversed&#125;&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-常用方法"><a href="#5-3-常用方法" class="headerlink" title="5-3 常用方法"></a>5-3 常用方法</h2><ul><li>add(增加)、addAll(拼接数组)、remove(删除)、removeAt(删除)、fillRange(修改)。</li><li>indexOf(查找，如果查找不到则返回-1)、<code>insert(index, value)</code>(指定位置插入)。</li><li><code>insertAll(index, list)</code>(指定位置插入列表)、<code>join()</code>(列表转换成字符串格式)。</li><li><code>split()</code>(字符串转换成列表)、<code>toList()</code>(其他类型转换成列表)。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 常用方法  List l1 &#x3D; [&#39;桃子&#39;];  l1.add(&#39;香蕉&#39;);  l1.addAll([&#39;葡萄&#39;, &#39;樱桃&#39;]);  print(&#39;列表：$l1&#39;);  &#x2F;&#x2F; 查找不到则返回-1  print(&#39;查找：$&#123;l1.indexOf(&#39;苹果&#39;)&#125;&#39;);   l1.remove(&#39;葡萄&#39;);  print(&#39;删除“葡萄”：$l1&#39;);  l1.removeAt(1);  print(&#39;删除“香蕉”：$l1&#39;);  &#x2F;&#x2F; 将位置(1-2]之间的数据改为&#39;西瓜&#39;  l1.fillRange(1, 2, &#39;西瓜&#39;);  print(&#39;替换“樱桃”：$l1&#39;);  l1.insert(1, &#39;杏子&#39;);  print(&#39;插入：$l1&#39;);  l1.insertAll(1, [&#39;苹果&#39;, &#39;龙眼&#39;]);  print(&#39;插入：$l1&#39;);  var str &#x3D; l1.join(&#39;、&#39;);  print(&#39;转换：$str&#39;);  var l2 &#x3D; str.split(&#39;、&#39;);  print(&#39;转换：$l2&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-集合"><a href="#6-集合" class="headerlink" title="6 集合"></a>6 集合</h1><ul><li>最主要的功能就是去除数组中存在的重复内容。</li><li>无序且不能重复的集合，不能通过索引获取值。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 给数组去重  var s &#x3D; new Set();  s.add(&#39;苹果&#39;);  s.add(&#39;苹果&#39;);  s.add(&#39;苹果&#39;);  print(s);  print(s.toList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7 字符串"></a>7 字符串</h1><ul><li>字符串类型，使用单引号、双引号或三引号定义，开发中大量使用。</li><li>通过两种方式进行字符串的拼接：使用<code>$</code>符号，或<code>+</code>符号进行操作。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 字符串定义的几种方式  var str1 &#x3D; &#39;字符串定义方式一&#39;;  var str2 &#x3D; &quot;字符串定义方式二&quot;;  print(str1);  print(&#39;$str2\n&#39;);  String str3 &#x3D; &#39;字符串定义方式三&#39;;  String str4 &#x3D; &quot;字符串定义方式四&quot;;  print(str3);  print(&#39;$str4\n&#39;);  String str5 &#x3D; &#39;&#39;&#39;  字符串定义方式五  字符串定义方式五  &#39;&#39;&#39;;  String str6 &#x3D; &quot;&quot;&quot;  字符串定义方式六  字符串定义方式六  &quot;&quot;&quot;;  print(str5);  print(str6);  &#x2F;&#x2F; 字符串的拼接  String str7 &#x3D; &#39;你好&#39;;  String str8 &#x3D; &#39;张三&#39;;  print(&#39;拼接一：$str7，$str8&#39;);  print(&#39;拼接二：&#39; + str7 + &#39;，&#39; + str8);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-数据类型判断"><a href="#8-数据类型判断" class="headerlink" title="8 数据类型判断"></a>8 数据类型判断</h1><ul><li>使用<code>is</code>关键字来判断数据类型。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; is关键字判断数据类型  var str &#x3D; &#39;12345&#39;;  if(str is String) &#123;    print(&#39;String类型&#39;);  &#125; else if(str is int) &#123;    print(&#39;int类型&#39;);  &#125; else &#123;    print(&#39;除String和int的其他类型&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-数据类型转换"><a href="#9-数据类型转换" class="headerlink" title="9 数据类型转换"></a>9 数据类型转换</h1><ul><li>使用<code>parse()</code>将String类型转换成Number类型，<code>toString()</code>将Number类型转换成String类型。</li><li><code>isEmpty</code>可以用来判断字符串是否为空，为了防止转换过程中报错，可使用<code>try...catch</code>语句。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; String转Number：parse()  String str1 &#x3D; &#39;123&#39;;  var myNum1 &#x3D; int.parse(str1);  print(myNum1 is int);  String str2 &#x3D; &#39;123.3&#39;;  var myNum2 &#x3D; double.parse(str2);  print(myNum2 is double);  &#x2F;&#x2F; Number转String：toString()  var myNum3 &#x3D; 123;  var str3 &#x3D; myNum3.toString();  print(str3 is String);  &#x2F;&#x2F; 其他类型转Boolean类型  var str4 &#x3D; &#39;你好！&#39;;  if(str4.isEmpty) &#123;    print(&#39;为空&#39;);  &#125; else &#123;    print(&#39;不空&#39;);  &#125;  var myNum4;  if(myNum4 &#x3D;&#x3D; null) &#123;    print(&#39;为空&#39;);  &#125; else &#123;    print(&#39;不空&#39;);  &#125;    var myNum5 &#x3D; 0&#x2F;0;  if(myNum5.isNaN) &#123;    print(&#39;非数&#39;);  &#125; else &#123;    print(myNum5);  &#125;  &#x2F;&#x2F; 防止报错，使用try...catch语句  String price &#x3D; &#39;&#39;;  try &#123;    var myNum6 &#x3D; double.parse(price);    print(myNum6);    print(myNum6 is double);  &#125; catch(err) &#123;    print(0);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字 </tag>
            
            <tag> 布尔 </tag>
            
            <tag> 字典 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/posts/dart@02.html"/>
      <url>/posts/dart@02.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">运算符用于执行各种操作，例如算术、位运算等，是Dart代码中的基本构建块，用于对数据进行操作并控制程序流。</div><h1 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1 运算符"></a>1 运算符</h1><ul><li>位运算符：<code>&amp;</code>(与)、<code>|</code>(或)、<code>^</code>(异或)、<code>~expr</code>(一元位补码)、<code>&lt;&lt;</code>(左移)、<code>&gt;&gt;</code>(右移)。</li><li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>~/</code>(返回一整数值的除法)、<code>-expr</code>(一元减号即负号)。</li><li>关系运算符：<code>==</code>(等)、<code>!=</code>(不等)、<code>&gt;</code>(大于)、<code>&lt;</code>(小于)、<code>&gt;=</code>(大于等于)、<code>&lt;=</code>(小于等于)。</li><li>赋值运算符：<code>=</code>、<code>??=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>~/=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>。</li><li>逻辑运算符：<code>!expr</code>(反转表达式)、<code>||</code>(逻辑或)、<code>&amp;&amp;</code>(逻辑与)，只两个值。</li><li>级联运算符：<code>..</code>(可对同一对象执行系列操作，严格说级联符号并非运算符)。</li><li>条件表达式：<code>condition ? expr1 : expr2</code>(三元表达式)、<code>expr1 ?? expr2</code>。</li><li>类型判定运算符：<code>is</code>(相应类型)、<code>is!</code>(非相应类型)、<code>as</code>(转换为指定类型)。</li></ul><h1 id="2-位运算符"><a href="#2-位运算符" class="headerlink" title="2 位运算符"></a>2 位运算符</h1><ul><li><code>^</code>(异或)：两个输入相同时为0，不同为1。</li><li>都是通过操作位的移动来达到运算的目的。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 位运算符  final v &#x3D; 0x77; &#x2F;&#x2F; 16进制，10进制为119，2进制为0111 0111  final b &#x3D; 0xee; &#x2F;&#x2F; 16进制，10进制为238，2进制为1110 1110  print((v &amp; b).toRadixString(2));  print((v | b).toRadixString(2));  print((v ^ b).toRadixString(2));  print((~ v).toRadixString(2));  print((v &lt;&lt; 1).toRadixString(2));  print((v &gt;&gt; 2).toRadixString(2));  print((v &amp;~ b).toRadixString(2)); &#x2F;&#x2F; 与非&amp;~，转为2进制&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-算术运算符"><a href="#3-算术运算符" class="headerlink" title="3 算术运算符"></a>3 算术运算符</h1><ul><li><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>(取余)、<code>~/</code>(返回一整数值的除法)、<code>-expr</code>(一元减号即负号)。</li><li>还支持前缀递增<code>++var</code>、前缀递减<code>--var</code>、后缀递增<code>var++</code>、后缀递减<code>var--</code>运算符。</li></ul><h2 id="3-1-加减乘除"><a href="#3-1-加减乘除" class="headerlink" title="3-1 加减乘除"></a>3-1 加减乘除</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 算术运算符  var a &#x3D; 3;  var b &#x3D; 6;  var c &#x3D; 9;  print(&#39;加：&#39; + (a + c).toString());  print(&#39;减：&#39; + (a - b).toString());  print(&#39;乘：&#39; + (a * b).toString());  print(&#39;除：&#39; + (c &#x2F; b).toString());  print(&#39;取余：&#39; + (c % b).toString());  print(&#39;取整：&#39; + (c ~&#x2F; b).toString());  var d &#x3D; b - a;  print(&#39;赋值：&#39; + d.toString());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-递增递减"><a href="#3-2-递增递减" class="headerlink" title="3-2 递增递减"></a>3-2 递增递减</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  var a &#x3D; 3;  var x1, x2, y1, y2;  &#x2F;&#x2F; 在x1获得值前自增a  x1 &#x3D; ++a;  print(&#39;$a --- $x1&#39;);  &#x2F;&#x2F; 在y1获得值后自增a  y1 &#x3D; a++;  print(&#39;$a --- $y1&#39;);  &#x2F;&#x2F; 在x2获得值前自减a  x2 &#x3D; --a;  print(&#39;$a --- $x2&#39;);  &#x2F;&#x2F; 在y2获得值后自减a  y2 &#x3D; a--;  print(&#39;$a --- $y2&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-关系运算符"><a href="#4-关系运算符" class="headerlink" title="4 关系运算符"></a>4 关系运算符</h1><ul><li>测试两个对象是否表示相同的事务，使用<code>==</code>运算符。</li><li>确定两个对象是否完全相同，使用<code>identical()</code>函数。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 关系运算符  int a &#x3D; 5;  int b &#x3D; 3;  print(a !&#x3D; b);  print(a &gt; b);  print(a &gt;&#x3D; b);  print(a &#x3D;&#x3D; b);  print(a &lt; b);  print(a &lt;&#x3D; b);  &#x2F;&#x2F; 用于条件判断  if(a &gt; b) &#123;    print(&#39;a大于b&#39;);  &#125; else &#123;    print(&#39;a小于b&#39;);  &#125;  int c &#x3D; 5;  &#x2F;&#x2F; 判断对象是否完全相同  int d &#x3D; 6;  print(identical(c, d));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5 赋值运算符"></a>5 赋值运算符</h1><ul><li>使用<code>=</code>运算符从右向左进行赋值操作，当变量为空时，可以使用<code>??=</code>运算符进行赋值。</li><li>复合赋值运算符：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>~/=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 赋值运算符，从右向左  var v &#x3D; 1;  print(v);  &#x2F;&#x2F; 如果z为空，则将值分配给z，否则z保持不变  var z;  z ??&#x3D; v;  print(z);  &#x2F;&#x2F; 复合赋值运算符  var a &#x3D; 12;  a +&#x3D; 10;  print(a);  var b &#x3D; 4;  b *&#x3D; 3;  print(b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-逻辑运算符"><a href="#6-逻辑运算符" class="headerlink" title="6 逻辑运算符"></a>6 逻辑运算符</h1><ul><li>逻辑运算符也可以反转布尔表达式，或组合布尔表达式。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 逻辑运算符  bool flag1 &#x3D; true;  print(!flag1);  &#x2F;&#x2F; 逻辑或||  bool flag2 &#x3D; false;  bool flag3 &#x3D; false;  print(flag2 || flag3);    &#x2F;&#x2F; 逻辑与&amp;&amp;  print(flag1 &amp;&amp; flag2);  &#x2F;&#x2F; 组合表达式  int age &#x3D; 21;  String sex &#x3D; &#39;男&#39;;  if(age &#x3D;&#x3D; 23 &amp;&amp; sex &#x3D;&#x3D; &#39;男&#39;) &#123;    print(&#39;$age --- $sex&#39;);  &#125; else &#123;    print(&#39;不打印&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-级联运算符"><a href="#7-级联运算符" class="headerlink" title="7 级联运算符"></a>7 级联运算符</h1><ul><li>使用<code>..</code>表示，可对同一对象执行一系列操作，严格说级联的双点符号并非运算符。</li><li>只是Dart语法的一部分，类似于JavaScript中Promise的then处理，目的是简化代码。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  num age;  Person(this.name, this.age);  void printInfo() &#123;    print(&#39;$&#123;this.name&#125; --- $&#123;this.age&#125;&#39;);  &#125;&#125;main() &#123;  Person p &#x3D; new Person(&#39;张三&#39;, 21);  p.printInfo();  p.name &#x3D; &#39;李四&#39;;  p.age &#x3D; 22;  p.printInfo();    p    ..name &#x3D; &#39;王五&#39;    ..age &#x3D; 23    ..printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-条件表达式"><a href="#8-条件表达式" class="headerlink" title="8 条件表达式"></a>8 条件表达式</h1><ul><li><code>condition ? expr1 : expr2</code>：条件为真返回expr1，否则返回expr2(三元表达式)。</li><li><code>expr1 ?? expr2</code>：如果expr1为非空，返回expr1的值，否则计算并且返回expr2的值。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; if...else  bool flag1 &#x3D; true;  if(flag1) &#123;    print(&#39;正确&#39;);  &#125; else &#123;    print(&#39;错误&#39;);  &#125;    &#x2F;&#x2F; condition ? expr1 : expr2  var flag2 &#x3D; true;  String result &#x3D; flag2 ? &#39;正确&#39; : &#39;错误&#39;;  print(result);  &#x2F;&#x2F; expr1 ?? expr2  var x;  var y &#x3D; x ?? 1000;  print(y);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-类型判定运算符"><a href="#9-类型判定运算符" class="headerlink" title="9 类型判定运算符"></a>9 类型判定运算符</h1><ul><li><code>is</code>：当对象是相应类型时，返回true。</li><li><code>is!</code>：对象不是相应类型时，返回true。</li><li><code>as</code>：将一个对象转换为指定类型，前提是能够转换，转换之前可先用is进行判断。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 类型判定运算符  var a &#x3D; 123;  if(a is int) &#123;    print(&#39;a是int类型&#39;);  &#125; else &#123;    print(&#39;a是其他类型&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算术 </tag>
            
            <tag> 关系 </tag>
            
            <tag> 赋值 </tag>
            
            <tag> 逻辑 </tag>
            
            <tag> 级联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart概念</title>
      <link href="/posts/dart@01.html"/>
      <url>/posts/dart@01.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">Dart诞生于2011年10月10日，是一种“结构化的Web编程”语言，应用于Web、服务器、移动应用等领域的开发。</div><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>Dart程序有统一的程序入口，即<code>main()</code>函数入口，与Java、C或C++语言相似。</li><li>一切皆对象，所有对象都是类的实例，所有对象都继承自内置的Object类，类似于Java语言。</li><li>Dart语言是弱数据类型，指定类型非必须，指定数据类型和编译时的常量，可提高运行速度。</li><li>Dart没有public、protected和private的概念，私有特性通过变量或函数，加上下划线来表示。</li><li>Dart工具可以检查出warning警告信息和errors错误信息。<ul><li>警告信息，表明代码可能不工作，但是不会妨碍程序运行。</li><li>错误信息，可能是编译时的错误，也可能是运行时的错误。</li><li>编译时的错误将阻止程序运行，运行时的错误会以exception异常方式呈现。</li></ul></li></ul><h2 id="1-1-入口方法"><a href="#1-1-入口方法" class="headerlink" title="1-1 入口方法"></a>1-1 入口方法</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 入口方法&#x2F;&#x2F; main() &#123;&#x2F;&#x2F;   print(&#39;入口方法&#39;);&#x2F;&#x2F; &#125;&#x2F;&#x2F; 表示main方法没有返回值void main() &#123;  &#x2F;&#x2F; 打印信息  print(&#39;入口方法&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-注释方法"><a href="#1-2-注释方法" class="headerlink" title="1-2 注释方法"></a>1-2 注释方法</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F;  注释方法一&#x2F;*  注释方法二  *&#x2F;&#x2F;&#x2F;&#x2F; 注释方法三main() &#123;  print(&#39;注释方法&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2 关键字"></a>2 关键字</h1><ul><li>限制类保留字：<code>await</code>、<code>yield</code>。</li><li>上下文关键字：<code>async</code>、<code>hide</code>、<code>on</code>、<code>show</code>、<code>sync</code>。</li><li>保留字<ul><li><code>super</code>、<code>void</code>、<code>rethrow</code>、<code>while</code>、<code>this</code>、<code>try</code>、<code>return</code>、<code>do</code>。</li><li><code>const</code>、<code>true</code>、<code>finally</code>、<code>final</code>、<code>null</code>、<code>var</code>、<code>assert</code>、<code>is</code>。</li><li><code>break</code>、<code>case</code>、<code>default</code>、<code>class</code>、<code>with</code>、<code>new</code>、<code>throw</code>、<code>continue</code>。</li><li><code>catch</code>、<code>else</code>、<code>extends</code>、<code>false</code>、<code>enum</code>、<code>for</code>、<code>switch</code>、<code>if</code>、<code>in</code>。</li></ul></li><li>内置标识符<ul><li><code>abstract</code>、<code>dynamic</code>、<code>covariant</code>、<code>Function</code>、<code>export</code>、<code>set</code>。</li><li><code>operator</code>、<code>typedef</code>、<code>interface</code>、<code>external</code>、<code>import</code>、<code>get</code>、<code>part</code>。</li><li><code>deferred</code>、<code>library</code>、<code>implements</code>、<code>factory</code>、<code>static</code>、<code>as</code>、<code>mixin</code>。</li></ul></li></ul><h1 id="3-Dart库"><a href="#3-Dart库" class="headerlink" title="3 Dart库"></a>3 Dart库</h1><ul><li>自定义的库：<code>import &#39;lib/xxx.dart&#39;;</code>。</li><li>系统内置库：<code>import &#39;dart:convert&#39;;</code>。<ul><li><code>dart:io</code>：文件读写I/O相关操作的库。</li><li><code>dart:svg</code>：事件和动画的矢量图支持。</li><li><code>dart:core</code>：内建类型、对象及核心功能。</li><li><code>dart:html</code>：网页开发使用到的库，使用频率高。</li><li><code>dart:math</code>：数字常量及函数，提供随机数算法。</li><li><code>dart:async</code>：异步编程支持，提供Future和Stream类。</li><li><code>dart:convert</code>：不同类型之间的字符编码、解码支持。</li><li><code>dart:collection</code>：对<code>dart:core</code>内置库提供更多的集合支持。</li></ul></li><li>Pub包管理系统中的第三方库：<a href="https://pub.dev/">https://pub.dev/</a>。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;dart:math&#39;;main() &#123;  print(&#39;最小值：&#39; + min(25, 27).toString());  print(&#39;最大值：&#39; + max(25, 27).toString());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1-实现请求数据"><a href="#3-1-实现请求数据" class="headerlink" title="3-1 实现请求数据"></a>3-1 实现请求数据</h2><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;dart:io&#39;;import &#39;dart:convert&#39;;void main() async &#123;  var result &#x3D; await getDataFromAPI();  print(result);&#125;&#x2F;&#x2F; API接口：http:&#x2F;&#x2F;news-at.zhihu.com&#x2F;api&#x2F;3&#x2F;stories&#x2F;latestgetDataFromAPI() async &#123;  &#x2F;&#x2F; 创建HTTPClient对象  var httpClient &#x3D; new HttpClient();  &#x2F;&#x2F; 创建URI对象  var uri &#x3D; new Uri.http(&#39;news-at.zhihu.com&#39;, &#39;&#x2F;api&#x2F;3&#x2F;stories&#x2F;latest&#39;);  &#x2F;&#x2F; 发起请求，等待响应  var request &#x3D; await httpClient.getUrl(uri);  &#x2F;&#x2F; 关闭请求，等待响应  var response &#x3D; await request.close();  &#x2F;&#x2F; 解码响应的内容  return await response.transform(utf8.decoder).join();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-async和await"><a href="#3-2-async和await" class="headerlink" title="3-2 async和await"></a>3-2 async和await</h2><ul><li>只有async方法才能使用await关键字调用方法。</li><li>如果调用别的async方法必须使用await关键字。</li><li>async是让方法变成异步，await是等待异步方法执行完成。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void main() async &#123;  var result &#x3D; await testAsync();  print(result);&#125;&#x2F;&#x2F; 异步方法testAsync() async &#123;  return &#39;异步方法&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-导入第三方库"><a href="#3-3-导入第三方库" class="headerlink" title="3-3 导入第三方库"></a>3-3 导入第三方库</h2><ul><li>项目的根目录下新建一个<code>pubspec.yaml</code>文件，在文件中配置名称、描述、依赖等信息。</li><li>命令窗口进入<code>pubspec.yaml</code>文件路径下，输入<code>dart pub get</code>回车获取包下载到本地。</li><li>项目中引入库需使用import命令，例如：<code>import &#39;package:http/http.dart&#39; as http;</code>。</li></ul><h3 id="1-pubspec-yaml"><a href="#1-pubspec-yaml" class="headerlink" title="(1) pubspec.yaml"></a>(1) pubspec.yaml</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">name: xxxdescription: pubtestenvironment:  sdk: &#39;&gt;&#x3D;2.10.0 &lt;3.0.0&#39;dependencies:  http: ^0.13.5  date_format: ^2.0.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用第三方库"><a href="#2-使用第三方库" class="headerlink" title="(2) 使用第三方库"></a>(2) 使用第三方库</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;dart:convert&#39; as convert;import &#39;package:http&#x2F;http.dart&#39; as http;import &#39;package:date_format&#x2F;date_format.dart&#39;;main() async &#123;  var url &#x3D; Uri.http(&#39;news-at.zhihu.com&#39;, &#39;&#x2F;api&#x2F;3&#x2F;stories&#x2F;latest&#39;);  &#x2F;&#x2F; 等待HTTP响应，然后对Json格式的响应进行解码  var response &#x3D; await http.get(url);  if (response.statusCode &#x3D;&#x3D; 200) &#123;    var jsonResponse &#x3D; convert.jsonDecode(response.body);    print(jsonResponse);  &#125; else &#123;    print(&#39;请求失败，状态为：$&#123;response.statusCode&#125;&#39;);  &#125;  print(formatDate(DateTime(2024, 01, 03), [yyyy, &#39;-&#39;, mm, &#39;-&#39;, dd]));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-库的冲突问题"><a href="#3-4-库的冲突问题" class="headerlink" title="3-4 库的冲突问题"></a>3-4 库的冲突问题</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">lib:  - person1.dart  - person2.dart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-person1-dart"><a href="#1-person1-dart" class="headerlink" title="(1) person1.dart"></a>(1) person1.dart</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  int age;  &#x2F;&#x2F; 默认构造函数的简写  Person(this.name, this.age);  Person.setInfo(String name, int age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;  &#125;  void printInfo() &#123;    print(&#39;Person1：$&#123;this.name&#125;---$&#123;this.age&#125;&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-person2-dart"><a href="#2-person2-dart" class="headerlink" title="(2) person2.dart"></a>(2) person2.dart</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  int age;  &#x2F;&#x2F; 默认构造函数的简写  Person(this.name, this.age);  Person.setInfo(String name, int age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;  &#125;  void printInfo() &#123;    print(&#39;Person2：$&#123;this.name&#125;---$&#123;this.age&#125;&#39;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-重命名一个库"><a href="#3-重命名一个库" class="headerlink" title="(3) 重命名一个库"></a>(3) 重命名一个库</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;lib&#x2F;person1.dart&#39;;import &#39;lib&#x2F;person2.dart&#39; as lib;main() &#123;  Person p1 &#x3D; new Person(&#39;张三&#39;, 21);  p1.printInfo();  lib.Person p2 &#x3D; new lib.Person(&#39;李四&#39;, 22);  p2.printInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-引入部分功能"><a href="#3-5-引入部分功能" class="headerlink" title="3-5 引入部分功能"></a>3-5 引入部分功能</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">lib:  - info.dart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-info-dart"><a href="#1-info-dart" class="headerlink" title="(1) info.dart"></a>(1) info.dart</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void getName() &#123;  print(&#39;张三&#39;);&#125;void getAge() &#123;  print(21);&#125;void getSex() &#123;  print(&#39;男&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-关键字使用"><a href="#2-关键字使用" class="headerlink" title="(2) 关键字使用"></a>(2) 关键字使用</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 隐藏不需要的部分，使用hide关键字import &#39;lib&#x2F;info.dart&#39; hide getAge;&#x2F;&#x2F; 只导入需要的部分，使用show关键字import &#39;lib&#x2F;info.dart&#39; show getName;void main() &#123;  getName();  &#x2F;&#x2F; 已隐藏，会报错  &#x2F;&#x2F; getAge();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-延迟加载-懒加载"><a href="#3-6-延迟加载-懒加载" class="headerlink" title="3-6 延迟加载(懒加载)"></a>3-6 延迟加载(懒加载)</h2><ul><li>懒加载：即需要时再加载，最大好处是减少APP的启动时间，通过<code>loadLibrary()</code>方法加载。</li><li>使用deferred as关键字进行指定，例如：<code>import &#39;lib/hello.dart&#39; deferred as hello;</code>。</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">lib:  - hello.dart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-hello-dart"><a href="#1-hello-dart" class="headerlink" title="(1) hello.dart"></a>(1) hello.dart</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void sayHello() &#123;  print(&#39;你好！&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-deferred-as"><a href="#2-deferred-as" class="headerlink" title="(2) deferred as"></a>(2) deferred as</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;lib&#x2F;hello.dart&#39; deferred as hello;void main() async &#123;  await hello.loadLibrary();  hello.sayHello();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-变量类型"><a href="#4-变量类型" class="headerlink" title="4 变量类型"></a>4 变量类型</h1><ul><li>Dart是脚本类语言，可以不预先定义变量类型，它会自动推导类型。</li><li>可以使用var关键字来声明变量，也可以通过类型关键字来定义变量。</li><li>变量命名规则<ul><li>变量名必须由数字、字母、下划线<code>_</code>和美元符<code>$</code>组成。</li><li>标识符开头不能是数字，标识符不能是保留字和关键字。</li><li>变量名区分大小写，尽量见名知义，变量名用名词，方法名用动词。</li></ul></li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 使用var关键字定义变量  var str1 &#x3D; &#39;var关键字定义变量&#39;;  print(str1);  var num1 &#x3D; 123;  print(&#39;var关键字定义变量：$num1&#39;);  &#x2F;&#x2F; 通过类型关键字定义变量  String str2 &#x3D; &#39;类型关键字定义变量&#39;;  print(str2);  int num2 &#x3D; 12345;  print(&#39;类型关键字定义变量：$num2&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-常量类型"><a href="#5-常量类型" class="headerlink" title="5 常量类型"></a>5 常量类型</h1><ul><li>常量：定义的变量不变，使用final或const关键字定义。</li><li>final是惰性初始化，即在运行时第一次使用前才初始化。</li><li>final的值只能被设定一次，是一个运行时常量，const则是一个编译时常量。</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  String str &#x3D; &#39;变量值1&#39;;  &#x2F;&#x2F; 变量可以改变值  str &#x3D; &#39;变量值2&#39;;  print(&#39;定义变量：$str&#39;);  &#x2F;&#x2F; const关键字定义常量  const PI1 &#x3D; 3.14159;  &#x2F;&#x2F; 常量不可以改变值，改变值将报错  &#x2F;&#x2F; PI1 &#x3D; 3.14159267;  print(&#39;const关键字定义常量：$PI1&#39;);  &#x2F;&#x2F; final关键字定义常量  final PI2 &#x3D; 3.14159;  &#x2F;&#x2F; PI2 &#x3D; 3.14159253;  print(&#39;final关键字定义常量：$PI2&#39;);  &#x2F;&#x2F; final关键字是运行时常量  final time1 &#x3D; new DateTime.now();  print(time1);    &#x2F;&#x2F; const关键字是编译时常量  &#x2F;&#x2F; const time2 &#x3D; new DateTime.now();  &#x2F;&#x2F; print(time2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库 </tag>
            
            <tag> 注释 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 常量 </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
